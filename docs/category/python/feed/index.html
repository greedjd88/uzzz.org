<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Python &#8211; 有组织在!</title>
	<atom:link href="https://uzzz.org/category/python/feed" rel="self" type="application/rss+xml" />
	<link>http://uzzz.org/</link>
	<description></description>
	<lastBuildDate>Fri, 30 Aug 2019 07:39:16 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.4</generator>

<image>
	<url>https://uzzz.org/wp-content/uploads/2019/10/cropped-icon-32x32.png</url>
	<title>Python &#8211; 有组织在!</title>
	<link>http://uzzz.org/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Dark web爬虫</title>
		<link>https://uzzz.org/article/795.html</link>
				<pubDate>Fri, 30 Aug 2019 07:39:16 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Python]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/795.html</guid>
				<description><![CDATA[deep_web&#8211;python 如何进入 环境搭建 开始 demo 如何进入 url多以onion结尾，访问的方式与普通的域名访问方式也不相同，访问他们需要一款名叫Tor的浏览器。也叫洋葱浏览器 环境搭建 针对于win10系统: tor浏览器。 Vidalia控制器。 Tor控制器。 cow 。 还要有一款支持socks5协议的工具 开始 首先打开tor浏览器，点击配置，点击选择内置网桥，选择中国可用的选项。出现以下界面说明你的tor连接成功了。 打开Vidalia控制面板，如图说明你的连接洋葱浏览器成功。 点击设定在该目录中找到解压的tor控制器中的tor.exe文件 3.网络设置 4.打开socks5软件，端口监听1080,好像ssr之类的默认就是1080 5.打开cow文件夹中的rc.txt文件 修改为 以后打开cow.exe 到此环境搭建完成 demo import requests proxies = {'http': 'http://127.0.0.1:7777', 'https': 'http://127.0.0.1:7777'} s = requests.Session() r = s.get("http://anonymzn3twqpxq5.onion/list.php?2", proxies = proxies) print(r.text)]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div id="content_views" class="markdown_views prism-atom-one-dark">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<div class="toc">
<h3>deep_web&#8211;python</h3>
<ul>
<li><a href="#_2" rel="nofollow" data-token="22f4fb37863c57e3f17343ed845db9e6">如何进入</a></li>
<ul>
<li><a href="#_6" rel="nofollow" data-token="c73bec32456401c45e0aa4e6fcc2948e">环境搭建</a></li>
<li><a href="#_15" rel="nofollow" data-token="f93e6c402fce0ccf2d5ff74e2b7d5e5c">开始</a></li>
<li><a href="#demo_32" rel="nofollow" data-token="06bd62ebcb94d7d2db73e99c0f7b1742">demo</a></li>
</ul>
</ul></div>
</p>
<h1><a id="_2"></a>如何进入</h1>
<p>url多以onion结尾，访问的方式与普通的域名访问方式也不相同，访问他们需要一款名叫Tor的浏览器。也叫洋葱浏览器</p>
<h2><a id="_6"></a>环境搭建</h2>
<p>针对于win10系统:</p>
<ol>
<li>tor浏览器。</li>
<li>Vidalia控制器。</li>
<li>Tor控制器。</li>
<li>cow 。</li>
<li>还要有一款支持socks5协议的工具</li>
</ol>
<h2><a id="_15"></a>开始</h2>
<ol>
<li>
<p>首先打开tor浏览器，点击配置，点击选择内置网桥，选择中国可用的选项。出现以下界面说明你的tor连接成功了。<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190426142422799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0Njc4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li>
<p>打开Vidalia控制面板，如图说明你的连接洋葱浏览器成功。<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019042614262299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0Njc4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br /> 点击设定在该目录中找到解压的tor控制器中的tor.exe文件<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/201904261428274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0Njc4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br /> 3.网络设置<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190426143056868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0Njc4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br /> 4.打开socks5软件，端口监听1080,好像ssr之类的默认就是1080<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190426143241954.png" alt="在这里插入图片描述"><br /> 5.打开cow文件夹中的rc.txt文件 修改为<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190426143418631.png" alt="在这里插入图片描述"><br /> 以后打开cow.exe<br /> 到此环境搭建完成</p>
</li>
</ol>
<h2><a id="demo_32"></a>demo</h2>
<pre><code class="prism language-javascript"><span class="token keyword">import</span> requests
proxies <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'http'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:7777'</span><span class="token punctuation">,</span> <span class="token string">'https'</span><span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:7777'</span><span class="token punctuation">}</span>
s <span class="token operator">=</span> requests<span class="token punctuation">.</span><span class="token function">Session</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
r <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"http://anonymzn3twqpxq5.onion/list.php?2"</span><span class="token punctuation">,</span> proxies <span class="token operator">=</span> proxies<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>text<span class="token punctuation">)</span>

</code></pre>
<p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190915172025956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0Njc4MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</p></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e9f16cbbc2.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
		<item>
		<title>使用darknet识别点选验证码详细过程（附带源码）</title>
		<link>https://uzzz.org/article/1407.html</link>
				<pubDate>Thu, 21 Mar 2019 15:06:33 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[机器学习]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/1407.html</guid>
				<description><![CDATA[项目源码：https://github.com/nickliqian/darknet_captcha darknet_captcha 项目基于darknet开发了一系列的快速启动脚本，旨在让图像识别新手或者开发人员能够快速的启动一个目标检测（定位）的项目。 如果有没有讲清楚的地方，欢迎提issue和PR，希望能和大家共同完善！ 本项目分为两个部分： 提供两个目标检测（单分类和多分类点选验证码）的例子，你可以通过例子熟悉定位yolo3定位网络的使用方式 基于darknet提供一系列API，用于使用自己的数据进行目标检测模型的训练，并提供web server的代码 目录 项目结构 开始一个例子：单类型目标检测 第二个例子：多类型目标检测 训练自己的数据 Web服务 API文档 其他问题 使用阿里云OSS加速下载 GPU云推荐 CPU和GPU识别速度对比 报错解决办法 TODO 项目结构 项目分为darknet、extent、app三部分 darknet: 这部分是darknet项目源码，没有作任何改动。 extent: 扩展部分，包含生成配置、生成样本、训练、识别demo、api程序。 app: 每一个新的识别需求都以app区分，其中包含配置文件、样本和标签文件等。 开始一个例子：单类型目标检测 以点选验证码为例 darknet实际上给我们提供了一系列的深度学习算法，我们要做的就是使用比较简单的步骤来调用darknet训练我们的识别模型。 推荐使用的操作系统是ubuntu，遇到的坑会少很多。 如果使用windowns系统，需要先安装cygwin，便于编译darknet。（参考我的博客：安装cygwin） 下面的步骤都已经通过ubuntu16.04测试。 1.下载项目 git clone https://github.com/nickliqian/darknet_captcha.git 2.编译darknet 进入darknet_captcha目录，下载darknet项目，覆盖darknet目录： cd darknet_captcha git clone https://github.com/pjreddie/darknet.git 进入darknet目录，修改darknet/Makefile配置文件 cd darknet vim Makefile 如果使用GPU训练则下面的GPU=1 使用CPU训练则下面的GPU=0 GPU=1 CUDNN=0 OPENCV=0 OPENMP=0 DEBUG=0 然后使用make编译darknet： make 不建议使用CPU进行训练，因为使用CPU不管是训练还是预测，耗时都非常久。 如果你需要租用临时且价格低的GPU主机进行测试，后面介绍了一些推荐的GPU云服务。 如果在编译过程中会出错，可以在darknet的issue找一下解决办法，也可以发邮件找我要旧版本的darknet。 3.安装python3环境 使用pip执行下面的语句，并确保你的系统上已经安装了tk： pip install -r requirement.txt sudo apt-get install python3-tk 4.创建一个应用 进入根目录，运行下面的程序生成一个应用的基本配置： cd darknet_captcha python3 extend/create_app_config.py my_captcha 1 这里的类别默认生成classes_1，你可以修改类别名称； 打开app/my_captcha/my_captcha.names修改classes_1为主机想要的名称即可。 如何查看create_app_config.py的命令行参数解释？ 直接运行python create_app_config.py便可以在控制台查看，下面的程序也是如此。 如果你对darknet相关配置有一定的了解，可以直接打开文件修改参数的值，这里我们保持原样即可。 5.生成样本 生成样本使用另外一个项目 nickliqian/generate_click_captcha 这里我已经集成进去了，执行下面的命令生成样本和对应标签到指定应用中yolo规定的目录： python3 extend/generate_click_captcha.py my_captcha 运行python generate_click_captcha.py查看参数解释。 6.划分训练集和验证集 运行下面的程序，划分训练集和验证集，同时将标签的值转换为yolo认识的格式： python3 extend/output_label.py my_captcha 1 这里填写的种类需要与上面一致。 运行python output_label.py查看参数解释。 7.开始训练 到这里，我们要准备的东西还差一样，我们需要下载darknet提供的预训练模型放在darknet_captcha目录下： wget https://pjreddie.com/media/files/darknet53.conv.74 在darknet_captcha目录下，执行下面的命令开始训练： ./darknet/darknet detector train app/my_captcha/my_captcha.data app/my_captcha/my_captcha_train.yolov3.cfg darknet53.conv.74 训练过程中模型会每一百次迭代储存一次，储存在app/my_captcha/backup/下，可以进行查看。 8.识别效果 使用GTX 1060训练大概1.5小时，训练迭代到1000次，会有比较明显的效果。 我们找一张验证集的图片使用不同进度下的模型进行识别测试，执行下面的语句开始识别： python3 extend/rec.py my_captcha 100 这里的100是选择app/my_captcha/images_data/JPEGImages目录下的第一百张图片进行识别。 运行python rec.py查看参数解释。 迭代300次： 迭代800次： 迭代1000次： 迭代1200次： 9.图片切割 这部分比较简单，网上有很多示例代码，可以调用darknet_interface.cut_and_save方法把定位到的字符切割下来。 10.分类器 到分类这一步就比较容易了，可以使用darknet自带的分类器，也可以使用cnn_captcha一个使用卷积神经网络识别验证码的项目。 11.总结 我们识别点选验证码的大致流程如下： 搜集样本 打标签（标注坐标和字符） 训练定位器 检测位置，切割图片 训练分类器 使用定位器+分类器识别点选验证码上字符的位置和字符类别 第二个例子：多类型目标检测 步骤和上面基本上一致，直接把命令列出来： # 生成配置文件 python3 extend/create_app_config.py dummy_captcha 2 # 生成图片 python3 extend/generate_click_captcha.py dummy_captcha 500 True # 输出标签到txt python3 extend/output_label.py dummy_captcha 2 # 开始训练w ./darknet/darknet detector train app/dummy_captcha/dummy_captcha.data app/dummy_captcha/dummy_captcha_train.yolov3.cfg darknet53.conv.74 # 识别测试 python3 extend/rec.py dummy_captcha 100 训练自己的数据]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div id="content_views" class="markdown_views prism-atom-one-dark">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<p>项目源码：<a href="https://github.com/nickliqian/darknet_captcha" rel="nofollow" data-token="bbe2c7667b3860ca3d312bfc79eac8c5">https://github.com/nickliqian/darknet_captcha</a></p>
<h1><a id="darknet_captcha_1"></a>darknet_captcha</h1>
<p>项目基于darknet开发了一系列的快速启动脚本，旨在让图像识别新手或者开发人员能够快速的启动一个目标检测（定位）的项目。<br /> 如果有没有讲清楚的地方，欢迎提issue和PR，希望能和大家共同完善！</p>
<p>本项目分为两个部分：</p>
<ol>
<li>提供两个目标检测（<strong>单分类和多分类点选验证码</strong>）的例子，你可以通过例子熟悉定位yolo3定位网络的使用方式</li>
<li>基于darknet提供一系列API，用于使用<strong>自己的数据</strong>进行目标检测模型的训练，并提供web server的代码<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190321230022127.jpg" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190321230043287.jpg" alt="在这里插入图片描述"><br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190321230056211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5ODQwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190321230103266.jpg" alt="在这里插入图片描述"></li>
</ol>
<h1><a id="_11"></a>目录</h1>
<ul>
<li><a href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84" rel="nofollow" data-token="e3cbb68166d7c73612de3c0f2d8b45c6">项目结构</a></li>
<li><a href="#%E5%BC%80%E5%A7%8B%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%8D%95%E7%B1%BB%E5%9E%8B%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B" rel="nofollow" data-token="560cba2a0ed3ef673a7f8f820d8d4a1e">开始一个例子：单类型目标检测</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%A4%9A%E7%B1%BB%E5%9E%8B%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B" rel="nofollow" data-token="5dd41eef749a59fc22928cd1b18d037b">第二个例子：多类型目标检测</a></li>
<li><a href="#%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE" rel="nofollow" data-token="840083843945e74ca8091f34e29a5a50">训练自己的数据</a></li>
<li><a href="#web%E6%9C%8D%E5%8A%A1" rel="nofollow" data-token="f21cb879da123717190c98419efeebf1">Web服务</a></li>
<li><a href="#API%E6%96%87%E6%A1%A3" rel="nofollow" data-token="f87e5f2dde5b4e7171b2527339b00bac">API文档</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98" rel="nofollow" data-token="34df0cdf9eb93c33be13c1355c511280">其他问题</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%BD%BD" rel="nofollow" data-token="661678172549864fcbc2e6f6281463c6">使用阿里云OSS加速下载</a></li>
<li><a href="#GPU%E4%BA%91%E6%8E%A8%E8%8D%90" rel="nofollow" data-token="4c5b24d02e2778a6aed6853623fd5195">GPU云推荐</a></li>
<li><a href="#CPU%E5%92%8CGPU%E8%AF%86%E5%88%AB%E9%80%9F%E5%BA%A6%E5%AF%B9%E6%AF%94" rel="nofollow" data-token="9ff9cbe779fc908b6dfe29bd8421dc09">CPU和GPU识别速度对比</a></li>
</ul>
</li>
<li><a href="#%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95" rel="nofollow" data-token="b8b4502a5899c83abe3e0bbf6b10e0ec">报错解决办法</a></li>
<li><a href="#TODO" rel="nofollow" data-token="da9cead761e3db3ac27337578bd89ec3">TODO</a></li>
</ul>
<h1><a id="_25"></a>项目结构</h1>
<p>项目分为<code>darknet、extent、app</code>三部分</p>
<ol>
<li>darknet: 这部分是<a href="https://github.com/pjreddie/darknet" rel="nofollow" data-token="993f4a46bae6e583288b4ebc86111b92">darknet</a>项目源码，没有作任何改动。</li>
<li>extent: 扩展部分，包含<strong>生成配置</strong>、<strong>生成样本</strong>、<strong>训练</strong>、<strong>识别demo</strong>、<strong>api程序</strong>。</li>
<li>app: 每一个新的识别需求都以app区分，其中包含配置文件、样本和标签文件等。</li>
</ol>
<h1><a id="_31"></a>开始一个例子：单类型目标检测</h1>
<p><strong>以点选验证码为例</strong><br /> darknet实际上给我们提供了一系列的深度学习算法，我们要做的就是使用比较简单的步骤来调用darknet训练我们的识别模型。</p>
<ul>
<li>推荐使用的操作系统是<code>ubuntu</code>，遇到的坑会少很多。</li>
<li>如果使用windowns系统，需要先安装<code>cygwin</code>，便于编译darknet。（参考我的博客：<a href="https://blog.csdn.net/weixin_39198406/article/details/83020632" rel="nofollow" data-token="d3dffad050d9d40d9ff00266a708da7e">安装cygwin</a>）</li>
</ul>
<p>下面的步骤都已经通过<code>ubuntu16.04</code>测试。</p>
<h4><a id="1_38"></a>1.下载项目</h4>
<pre><code>git clone https://github.com/nickliqian/darknet_captcha.git
</code></pre>
<h4><a id="2darknet_42"></a>2.编译darknet</h4>
<p>进入<code>darknet_captcha</code>目录，下载<code>darknet</code>项目，覆盖<code>darknet</code>目录：</p>
<pre><code>cd darknet_captcha
git clone https://github.com/pjreddie/darknet.git
</code></pre>
<p>进入<code>darknet</code>目录，修改<code>darknet/Makefile</code>配置文件</p>
<pre><code>cd darknet
vim Makefile
</code></pre>
<ul>
<li>如果使用GPU训练则下面的GPU=1</li>
<li>使用CPU训练则下面的GPU=0</li>
</ul>
<pre><code>GPU=1
CUDNN=0
OPENCV=0
OPENMP=0
DEBUG=0
</code></pre>
<p>然后使用<code>make</code>编译<code>darknet</code>：</p>
<pre><code>make
</code></pre>
<blockquote>
<p>不建议使用CPU进行训练，因为使用CPU不管是训练还是预测，耗时都非常久。<br /> 如果你需要租用临时且价格低的GPU主机进行测试，后面介绍了一些推荐的GPU云服务。<br /> 如果在编译过程中会出错，可以在darknet的issue找一下解决办法，也可以发邮件找我要旧版本的darknet。</p>
</blockquote>
<h4><a id="3python3_70"></a>3.安装python3环境</h4>
<p>使用pip执行下面的语句，并确保你的系统上已经安装了tk：</p>
<pre><code>pip install -r requirement.txt
sudo apt-get install python3-tk
</code></pre>
<h4><a id="4_77"></a>4.创建一个应用</h4>
<p>进入根目录，运行下面的程序生成一个应用的基本配置：</p>
<pre><code>cd darknet_captcha
python3 extend/create_app_config.py my_captcha 1
</code></pre>
<p>这里的类别默认生成<code>classes_1</code>，你可以修改类别名称；<br /> 打开<code>app/my_captcha/my_captcha.names</code>修改<code>classes_1</code>为主机想要的名称即可。</p>
<p>如何查看<code>create_app_config.py</code>的命令行参数解释？<br /> 直接运行<code>python create_app_config.py</code>便可以在控制台查看，下面的程序也是如此。</p>
<blockquote>
<p>如果你对darknet相关配置有一定的了解，可以直接打开文件修改参数的值，这里我们保持原样即可。</p>
</blockquote>
<h4><a id="5_91"></a>5.生成样本</h4>
<p>生成样本使用另外一个项目 <a href="https://github.com/nickliqian/generate_click_captcha" rel="nofollow" data-token="7b93780a4f9d60f2d43ef3b928cc2f56">nickliqian/generate_click_captcha</a><br /> 这里我已经集成进去了，执行下面的命令生成样本和对应标签到指定应用中<code>yolo</code>规定的目录：</p>
<pre><code>python3 extend/generate_click_captcha.py my_captcha
</code></pre>
<p>运行<code>python generate_click_captcha.py</code>查看参数解释。</p>
<h4><a id="6_99"></a>6.划分训练集和验证集</h4>
<p>运行下面的程序，划分训练集和验证集，同时将标签的值转换为<code>yolo</code>认识的格式：</p>
<pre><code>python3 extend/output_label.py my_captcha 1
</code></pre>
<p>这里填写的种类需要与上面一致。<br /> 运行<code>python output_label.py</code>查看参数解释。</p>
<h4><a id="7_107"></a>7.开始训练</h4>
<p>到这里，我们要准备的东西还差一样，我们需要下载darknet提供的预训练模型放在<code>darknet_captcha</code>目录下：</p>
<pre><code>wget https://pjreddie.com/media/files/darknet53.conv.74
</code></pre>
<p>在<code>darknet_captcha</code>目录下，执行下面的命令开始训练：</p>
<pre><code>./darknet/darknet detector train app/my_captcha/my_captcha.data app/my_captcha/my_captcha_train.yolov3.cfg darknet53.conv.74
</code></pre>
<p>训练过程中模型会每一百次迭代储存一次，储存在<code>app/my_captcha/backup/</code>下，可以进行查看。</p>
<h4><a id="8_118"></a>8.识别效果</h4>
<p>使用<code>GTX 1060</code>训练大概1.5小时，训练迭代到1000次，会有比较明显的效果。</p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190321230224316.jpg" alt="在这里插入图片描述"><br /> 我们找一张验证集的图片使用不同进度下的模型进行识别测试，执行下面的语句开始识别：</p>
<pre><code>python3 extend/rec.py my_captcha 100
</code></pre>
<p>这里的100是选择<code>app/my_captcha/images_data/JPEGImages</code>目录下的第一百张图片进行识别。<br /> 运行<code>python rec.py</code>查看参数解释。</p>
<p>迭代300次：<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190321230246699.jpg" alt="在这里插入图片描述"><br /> 迭代800次：<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190321230254808.jpg" alt="在这里插入图片描述"><br /> 迭代1000次：<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190321230303211.jpg" alt="在这里插入图片描述"><br /> 迭代1200次：<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190321230312599.jpg" alt="在这里插入图片描述"></p>
<h4><a id="9_137"></a>9.图片切割</h4>
<p>这部分比较简单，网上有很多示例代码，可以调用<code>darknet_interface.cut_and_save</code>方法把定位到的字符切割下来。<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190321230421943.png" alt="在这里插入图片描述"></p>
<h4><a id="10_141"></a>10.分类器</h4>
<p>到分类这一步就比较容易了，可以使用darknet自带的分类器，也可以使用<a href="https://github.com/nickliqian/cnn_captcha" rel="nofollow" data-token="1beeb7f0521c4b0077accb44f90b0df3">cnn_captcha</a>一个使用卷积神经网络识别验证码的项目。</p>
<h4><a id="11_143"></a>11.总结</h4>
<p>我们识别点选验证码的大致流程如下：</p>
<ol>
<li>搜集样本</li>
<li>打标签（标注坐标和字符）</li>
<li>训练定位器</li>
<li>检测位置，切割图片</li>
<li>训练分类器</li>
<li>使用定位器+分类器识别点选验证码上字符的位置和字符类别</li>
</ol>
<h2><a id="_152"></a>第二个例子：多类型目标检测</h2>
<p>步骤和上面基本上一致，直接把命令列出来：</p>
<pre><code># 生成配置文件
python3 extend/create_app_config.py dummy_captcha 2
# 生成图片
python3 extend/generate_click_captcha.py dummy_captcha 500 True
# 输出标签到txt
python3 extend/output_label.py dummy_captcha 2
# 开始训练w
./darknet/darknet detector train app/dummy_captcha/dummy_captcha.data app/dummy_captcha/dummy_captcha_train.yolov3.cfg darknet53.conv.74
# 识别测试
python3 extend/rec.py dummy_captcha 100
</code></pre>
<h2><a id="_167"></a>训练自己的数据</h2>
<p>下面的过程教你如何训练自己数据。<br /> 假定我们要创建一个识别路上的车和人的应用，因此类别数量为2。<br /> 假定你现在有一些原始图片，首先你需要给这些图片打上标签，推荐使用<a href="https://github.com/tzutalin/labelImg" rel="nofollow" data-token="1e1d91f57353c3b2de80c67156a204c0">labelImg</a>进行打标工作。<br /> 使用教程可以自行谷歌，软件界面大致如下：<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190321230438799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5ODQwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>给图片中的人和车分别打上person和car的标签，会生成xml标签文件。<br /> 接下来，我们创建一个应用，应用名称是<code>car</code>，类别为<code>2</code>类，同时生成一些配置文件：</p>
<pre><code>python3 extend/create_app_config.py car 2
</code></pre>
<p>然后把你的原始图片放到指定的路径<code>app/car/JPEGImages</code>，把xml标签文件放在<code>app/car/Annotations</code><br /> yolo训练的时候需要图片中目标的相对坐标，所以这里需要把xml的坐标计算为相对坐标的形式。<br /> 同时car.data中需要分别定义训练集和验证集的样本路径，这里会划分出训练集和验证集，同时生成两个txt文件记录其路径。</p>
<pre><code>python3 extend/output_label.py car 2
</code></pre>
<p>要提到的是，这里可以打开car.names，把里面的class_1和class_2分别修改为car和person，这里识别结果就会输出car和person。<br /> 然后就可以开始训练了：</p>
<pre><code>./darknet/darknet detector train app/car/car.data app/car/car_train.yolov3.cfg darknet53.conv.74
</code></pre>
<p>识别测试和上面也没有上面区别：</p>
<pre><code># 识别测试
python3 extend/rec.py car 100
</code></pre>
<h2><a id="web_195"></a>web服务</h2>
<p>启动web服务：</p>
<pre><code>python3 extend/web_server.py
</code></pre>
<p>启动前需要按需修改配置参数：</p>
<pre><code># 生成识别对象，需要配置参数
app_name = "car"  # 应用名称
config_file = "app/{}/{}_train.yolov3.cfg".format(app_name, app_name)  # 配置文件路径
model_file = "app/{}/backup/{}_train.backup".format(app_name, app_name)  # 模型路径
data_config_file = "app/{}/{}.data".format(app_name, app_name)  # 数据配置文件路径
dr = DarknetRecognize(
    config_file=config_file,
    model_file=model_file,
    data_config_file=data_config_file
)
save_path = "api_images"  # 保存图片的路径
</code></pre>
<p>使用下面的脚本<code>request_api.py</code>进行web服务的识别测试（注意修改图片路径）:</p>
<pre><code>python3 extend/request_api.py
</code></pre>
<p>返回响应，响应包含目标类别和中心点位置：</p>
<pre><code>接口响应: {
  "speed_time(ms)": 16469, 
  "time": "15472704635706885", 
  "value": [
    [
      "word", 
      0.9995613694190979, 
      [
        214.47508239746094, 
        105.97418212890625, 
        24.86412811279297, 
        33.40662384033203
      ]
    ],
    ...
}
</code></pre>
<h2><a id="API_237"></a>API文档</h2>
<p>暂无</p>
<h2><a id="_240"></a>其他问题</h2>
<h3><a id="OSS_241"></a>使用阿里云OSS加速下载</h3>
<p>如果你使用国外云主机进行训练，训练好的模型的下载速度确实是一个问题。<br /> 这里推荐使用阿里云oss，在云主机上把文件上传上去，然后使用oss下载下来。<br /> 配置秘钥：</p>
<pre><code># 从环境变量获取密钥
AccessKeyId = os.getenv("AccessKeyId")
AccessKeySecret = os.getenv("AccessKeySecret")
BucketName = os.getenv("BucketName")
</code></pre>
<p>上传图片：</p>
<pre><code>python3 extend/upload2oss.py app/my_captcha/images_data/JPEGImages/1_15463317590530567.jpg
python3 extend/upload2oss.py text.jpg
</code></pre>
<h3><a id="GPU_257"></a>GPU云推荐</h3>
<p>使用租用 vectordash GPU云主机，ssh连接集成了Nvidia深度学习环境的ubuntu16.04系统<br /> 包含以下工具或框架：</p>
<pre><code>CUDA 9.0, cuDNN, Tensorflow, PyTorch, Caffe, Keras
</code></pre>
<p>vectordash提供了一个客户端，具备远程连接、上传和下载文件、管理多个云主机等。<br /> 下面是几种显卡的租用价格：<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019032123045338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE5ODQwNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br /> 创建实例后，面板会提供一个秘钥，输入秘钥后，就可以使用客户端操作了：</p>
<pre><code># 安装客户端
pip install vectordash --upgrade
# 登录
vectordash login
# 列出主机
vectordash list
# ssh登录
vectordash ssh &lt;instance_id&gt;
# 打开jupyter
vectordash jupyter &lt;instance_id&gt;
# 上传文件
vectordash push &lt;instance_id&gt; &lt;from_path&gt; &lt;to_path&gt;
# 下载文件
vectordash pull &lt;instance_id&gt; &lt;from_path&gt; &lt;to_path&gt;
</code></pre>
<p>由于vectordash主机在国外，所以上传和下载都很慢，建议临时租用一台阿里云竞价突发型实例（约7分钱一小时）作为中转使用。</p>
<h3><a id="CPUGPU_285"></a>CPU和GPU识别速度对比</h3>
<p>GTX 1060, 识别耗时1s</p>
<pre><code>[load model] speed time: 4.691879987716675s
[detect image - i] speed time: 1.002530813217163s
</code></pre>
<p>CPU, 识别耗时13s</p>
<pre><code>[load model] speed time: 3.313053846359253s
[detect image - i] speed time: 13.256595849990845s
</code></pre>
<h2><a id="_297"></a>报错解决办法</h2>
<ol>
<li>UnicodeEncodeError: ‘ascii’ codec can’t encode character ‘\U0001f621’ in posit<br /> <a href="https://blog.csdn.net/u011415481/article/details/80794567" rel="nofollow" data-token="39d2177d12495f5471ded8c7eb62aa46">参考链接</a></li>
<li>pip install, locale.Error: unsupported locale setting<br /> <a href="https://blog.csdn.net/qq_33232071/article/details/51108062" rel="nofollow" data-token="99aa19d8b859c366914ec7034be979f2">参考链接</a></li>
</ol>
<h2><a id="TODO_303"></a>TODO</h2>
<ol>
<li>支持多类别检测的识别和训练 <strong>Done</strong></li>
<li>WebServer API调用 <strong>Done</strong></li>
<li>分类器</li>
</ol></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e9f16cbbc2.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
		<item>
		<title>TensorFlow学习笔记&#8211;Deep Dream模型</title>
		<link>https://uzzz.org/article/1677.html</link>
				<pubDate>Thu, 18 Oct 2018 06:17:59 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[Thomas带你领率谷歌AI的美丽]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/1677.html</guid>
				<description><![CDATA[零、目标 Deep Dream是谷歌推出的一个有意思的技术。在训练好的CNN上，设定几个参数就可以生成一张图象。具体目标是： 了解Deep Dream基本原理 掌握实现生成Deep Dream 模型 一、技术原理 在卷积网络中，通常输入的是一张图象，经过若干层的卷积运算，最终输出图像的类别。这期间使用到了图片计算梯度，网络根据梯度不断的调整和学习最佳的参数。但是卷积层究竟学习到了什么，卷积层的参数代表了什么，浅层卷积和深层卷积学习到的内容有哪些区别，这些问题Deep Dream可以解答。 假设输入网络的图像为X，网络输出的各个类别的概率为t（t是一个多维向量，代表了多种类别的概率）。设定t[N]为优化目标，不断的让神经网络去调整输入图像X的像素值，让输出t[N]尽可能的大，最后极大化第N类别的概率得到图片。 关于卷积层究竟学到了什么，只需要最大化卷积层的某一个通道数据就可以了。折输入的图像为X，中间某个卷积层的输出是Y，Y的形状是hwc，其中h为Y的高度，w为Y的宽度，c为通道数。卷积的一个通道就可以代表一种学习到的信息。以某一个通道的平均值作为优化目标，就可以弄清楚这个通道究竟学习到了什么，这也是Deep Dream的基本原理。 二、在TensorFlow中使用 导入Inception模型 原始的Deep Dream 模型只需要优化ImageNet 模型卷积层某个通道的激活值就可以。因此，应该先导入ImageNet图像识别模型，这里以 Inception 为例。创建 load_inception.py 文件，输入如下代码： # 导入基本模块 import numpy as np import tensorflow as tf # 创建图和会话 graph = tf.Graph() sess = tf.InteractiveSession(graph=graph) # 导入Inception模型 # tensorflow_inception_graph.pb 文件存储了inception的网络结构和对应的数据 model_fn = 'tensorflow_inception_graph.pb' with tf.gfile.FastGFile(model_fn, 'rb') as f: graph_def = tf.GraphDef() graph_def.ParseFromString(f.read()) # 导入的时候需要给网络制定一个输入图像，因此定义一个t_input作为占位符 # 需要注意的是，使用的图像数据通常的格式为：(height,width,channel)， # 其中height为图像的像素高度，width为图像的像素宽度，chaneel为图像的通道数，一般使用RGB图像，所以通道数为3 t_input = tf.placeholder(np.float32, name='input') imagenet_mean = 117.0 # 处理输入图像 # 虽然图像的格式是(height,width,channel)，但是Inception模型所需的输入格式是(batch,height,width,channel) # 这是因为(height,width,channel)只能表示一张图片，但在训练神经网络时往往需要多张图片 # 因此在前面加了一维，让输入的图片符合Inception需要的格式 # 尽管这里一次只需要输入一张图片,但是同样也需要将数据变为Inception所需的格式，只不过这里的batch等于1 # 对图像减去一个像素均值 # 原因是在训练Inception 模型的时候，已经做了减去均值的预处理，因此这里使用同样的方法处理，才能保持输入一致 # t_input-imagenet_mean 减去均值，这里使用的Inception模型减去的是一个固定均值117，所以这里也减去117 # expand_dims 执行加一维操作，从[height,width,channel] 变为[1,height,width,channel] t_preprocessed = tf.expand_dims(t_input - imagenet_mean, 0) # 导入模型 tf.import_graph_def(graph_def, {'input': t_preprocessed}) # 找到所有的卷积层 layers = [op.name for op in graph.get_operations() if op.type == 'Conv2D' and 'import/' in op.name] # 输出卷积层层数 print('Number of layers', len(layers)) # 输出mixed4d_3x3_bottleneck_pre_relu 形状 name = 'mixed4d_3x3_bottleneck_pre_relu' print('shape of %s: %s' % (name, str(graph.get_tensor_by_name('import/' + name + ':0').get_shape()))) 这段代码运行后，会输出卷积层总数是59个 注1： 在输出卷积层“mixed4d_3x3_bottleneck_pre_relu”的形状时，输出的结果是(?,?,?,144)，原因是此时还不清楚输入图像的个数以及大小，所以前三维的值不确定 生成原始图像 以 mixed4d_3x3_bottleneck_pre_relu 卷积层为例，最大化它的某一个通道的平均值，以达到生成图像的目的。 创建 gen_naive.py 文件，导入Inception模型，导入方法同上节。首先定义保存图片的函数： def savearray(img_array, img_name): scipy.misc.toimage(img_array).save(img_name) print('img saved : %s' % img_name) 接着创建程序的主要部分： # 定义卷积层、通道数，并去除对应的Tensor name = 'mixed4d_3x3_bottleneck_pre_relu' # 选择任意的通道，这里是139 channel = 139 # 取出 mixed4d_3x3_bottleneck_pre_relu 卷积层的输出层]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div id="content_views" class="markdown_views prism-tomorrow-night">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<h4><a id="_0"></a>零、目标</h4>
<p>Deep Dream是谷歌推出的一个有意思的技术。在训练好的CNN上，设定几个参数就可以生成一张图象。具体目标是：</p>
<ol>
<li>了解Deep Dream基本原理</li>
<li>掌握实现生成Deep Dream 模型</li>
</ol>
<h4><a id="_5"></a>一、技术原理</h4>
<p>在卷积网络中，通常输入的是一张图象，经过若干层的卷积运算，最终输出图像的类别。这期间使用到了图片计算梯度，网络根据梯度不断的调整和学习最佳的参数。但是卷积层究竟学习到了什么，卷积层的参数代表了什么，浅层卷积和深层卷积学习到的内容有哪些区别，这些问题Deep Dream可以解答。<br /> 假设输入网络的图像为X，网络输出的各个类别的概率为t（t是一个多维向量，代表了多种类别的概率）。设定t[N]为优化目标，不断的让神经网络去调整输入图像X的像素值，让输出t[N]尽可能的大，最后极大化第N类别的概率得到图片。<br /> 关于卷积层究竟学到了什么，只需要最大化卷积层的某一个通道数据就可以了。折输入的图像为X，中间某个卷积层的输出是Y，Y的形状是h<em>w</em>c，其中h为Y的高度，w为Y的宽度，c为通道数。卷积的一个通道就可以代表一种学习到的信息。以某一个通道的平均值作为优化目标，就可以弄清楚这个通道究竟学习到了什么，这也是Deep Dream的基本原理。</p>
<h4><a id="TensorFlow_10"></a>二、在TensorFlow中使用</h4>
<ol>
<li>导入Inception模型<br /> 原始的Deep Dream 模型只需要优化ImageNet 模型卷积层某个通道的激活值就可以。因此，应该先导入ImageNet图像识别模型，这里以 <strong>Inception</strong> 为例。创建 <strong>load_inception.py</strong> 文件，输入如下代码：</li>
</ol>
<pre><code class="prism language-python"><span class="token comment"># 导入基本模块</span>
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf

<span class="token comment"># 创建图和会话</span>
graph <span class="token operator">=</span> tf<span class="token punctuation">.</span>Graph<span class="token punctuation">(</span><span class="token punctuation">)</span>
sess <span class="token operator">=</span> tf<span class="token punctuation">.</span>InteractiveSession<span class="token punctuation">(</span>graph<span class="token operator">=</span>graph<span class="token punctuation">)</span>

<span class="token comment"># 导入Inception模型</span>
<span class="token comment"># tensorflow_inception_graph.pb 文件存储了inception的网络结构和对应的数据</span>
model_fn <span class="token operator">=</span> <span class="token string">'tensorflow_inception_graph.pb'</span>
<span class="token keyword">with</span> tf<span class="token punctuation">.</span>gfile<span class="token punctuation">.</span>FastGFile<span class="token punctuation">(</span>model_fn<span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    graph_def <span class="token operator">=</span> tf<span class="token punctuation">.</span>GraphDef<span class="token punctuation">(</span><span class="token punctuation">)</span>
    graph_def<span class="token punctuation">.</span>ParseFromString<span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>


<span class="token comment"># 导入的时候需要给网络制定一个输入图像，因此定义一个t_input作为占位符</span>
<span class="token comment"># 需要注意的是，使用的图像数据通常的格式为：(height,width,channel)，</span>
<span class="token comment"># 其中height为图像的像素高度，width为图像的像素宽度，chaneel为图像的通道数，一般使用RGB图像，所以通道数为3</span>
t_input <span class="token operator">=</span> tf<span class="token punctuation">.</span>placeholder<span class="token punctuation">(</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'input'</span><span class="token punctuation">)</span>
imagenet_mean <span class="token operator">=</span> <span class="token number">117.0</span>

<span class="token comment"># 处理输入图像</span>
<span class="token comment"># 虽然图像的格式是(height,width,channel)，但是Inception模型所需的输入格式是(batch,height,width,channel)</span>
<span class="token comment"># 这是因为(height,width,channel)只能表示一张图片，但在训练神经网络时往往需要多张图片</span>
<span class="token comment"># 因此在前面加了一维，让输入的图片符合Inception需要的格式</span>
<span class="token comment"># 尽管这里一次只需要输入一张图片,但是同样也需要将数据变为Inception所需的格式，只不过这里的batch等于1</span>
<span class="token comment"># 对图像减去一个像素均值</span>
<span class="token comment"># 原因是在训练Inception 模型的时候，已经做了减去均值的预处理，因此这里使用同样的方法处理，才能保持输入一致</span>
<span class="token comment"># t_input-imagenet_mean 减去均值，这里使用的Inception模型减去的是一个固定均值117，所以这里也减去117</span>
<span class="token comment"># expand_dims 执行加一维操作，从[height,width,channel] 变为[1,height,width,channel]</span>
t_preprocessed <span class="token operator">=</span> tf<span class="token punctuation">.</span>expand_dims<span class="token punctuation">(</span>t_input <span class="token operator">-</span> imagenet_mean<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment"># 导入模型</span>
tf<span class="token punctuation">.</span>import_graph_def<span class="token punctuation">(</span>graph_def<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'input'</span><span class="token punctuation">:</span> t_preprocessed<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment"># 找到所有的卷积层</span>
layers <span class="token operator">=</span> <span class="token punctuation">[</span>op<span class="token punctuation">.</span>name <span class="token keyword">for</span> op <span class="token keyword">in</span> graph<span class="token punctuation">.</span>get_operations<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> op<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> <span class="token string">'Conv2D'</span> <span class="token operator">and</span> <span class="token string">'import/'</span> <span class="token keyword">in</span> op<span class="token punctuation">.</span>name<span class="token punctuation">]</span>

<span class="token comment"># 输出卷积层层数</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Number of layers'</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>layers<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># 输出mixed4d_3x3_bottleneck_pre_relu 形状</span>
name <span class="token operator">=</span> <span class="token string">'mixed4d_3x3_bottleneck_pre_relu'</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'shape of %s: %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span>get_tensor_by_name<span class="token punctuation">(</span><span class="token string">'import/'</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">':0'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get_shape<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>


</code></pre>
<p>这段代码运行后，会输出卷积层总数是59个</p>
<blockquote>
<p>注1：<br /> 在输出卷积层“mixed4d_3x3_bottleneck_pre_relu”的形状时，输出的结果是(?,?,?,144)，原因是此时还不清楚输入图像的个数以及大小，所以前三维的值不确定</p>
</blockquote>
<ol start="2">
<li>生成原始图像<br /> 以 mixed4d_3x3_bottleneck_pre_relu 卷积层为例，最大化它的某一个通道的平均值，以达到生成图像的目的。<br /> 创建 <strong>gen_naive.py</strong> 文件，导入Inception模型，导入方法同上节。首先定义保存图片的函数：</li>
</ol>
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">savearray</span><span class="token punctuation">(</span>img_array<span class="token punctuation">,</span> img_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    scipy<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>toimage<span class="token punctuation">(</span>img_array<span class="token punctuation">)</span><span class="token punctuation">.</span>save<span class="token punctuation">(</span>img_name<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'img saved : %s'</span> <span class="token operator">%</span> img_name<span class="token punctuation">)</span>

</code></pre>
<p>接着创建程序的主要部分：</p>
<pre><code class="prism language-python"><span class="token comment"># 定义卷积层、通道数，并去除对应的Tensor</span>
name <span class="token operator">=</span> <span class="token string">'mixed4d_3x3_bottleneck_pre_relu'</span>
<span class="token comment"># 选择任意的通道，这里是139</span>
channel <span class="token operator">=</span> <span class="token number">139</span>
<span class="token comment"># 取出 mixed4d_3x3_bottleneck_pre_relu 卷积层的输出层</span>
layer_output <span class="token operator">=</span> graph<span class="token punctuation">.</span>get_tensor_by_name<span class="token punctuation">(</span><span class="token string">"import/%s:0"</span> <span class="token operator">%</span> name<span class="token punctuation">)</span>

<span class="token comment"># 定义原始的图像噪声</span>
<span class="token comment"># 他是一个形状为（224，224，3）的张量，表示初始化图像优化起点</span>
img_noise <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">100.0</span>

<span class="token comment"># 调用 render_navie 函数渲染</span>
render_naive<span class="token punctuation">(</span>layer_output<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> channel<span class="token punctuation">]</span><span class="token punctuation">,</span> img_noise<span class="token punctuation">,</span> iter_n<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>

</code></pre>
<p>最后定义渲染函数</p>
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">render_naive</span><span class="token punctuation">(</span>t_obj<span class="token punctuation">,</span> img0<span class="token punctuation">,</span> iter_n<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> step<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">''' 渲染函数 :param t_obj:卷积层某个通道的值 :param img0:初始化图像 :param iter_n:迭代的步数 :param step: :return: '''</span>
    <span class="token comment"># t_score 是优化目标。他是t_obj的平均值</span>
    <span class="token comment"># t_score 越大，就说明神经网络卷积层对应的通道的平均激活越大</span>
    t_score <span class="token operator">=</span> tf<span class="token punctuation">.</span>reduce_mean<span class="token punctuation">(</span>t_obj<span class="token punctuation">)</span>
    <span class="token comment"># 计算t_score对t_input的梯度</span>
    <span class="token comment"># 代码的目标是通过调整输入图像 t_input ，来让 t_score 尽可能的大</span>
    <span class="token comment"># 因此使用体服下降法</span>
    t_grad <span class="token operator">=</span> tf<span class="token punctuation">.</span>gradients<span class="token punctuation">(</span>t_score<span class="token punctuation">,</span> t_input<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

    <span class="token comment"># 创建新图</span>
    img <span class="token operator">=</span> img0<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 迭代 iter_n 每一步都将梯度应用到图像上</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>iter_n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 在sess中计算梯度，以及当前的score</span>
        g<span class="token punctuation">,</span> score <span class="token operator">=</span> sess<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">[</span>t_grad<span class="token punctuation">,</span> t_score<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>t_input<span class="token punctuation">:</span> img<span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token comment"># 对img应用梯度，step可以看作学习率</span>
        g <span class="token operator">/=</span> g<span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">8</span>
        img <span class="token operator">+=</span> g <span class="token operator">*</span> step
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'score(mean)=%f'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">)</span>

    savearray<span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token string">'navie.jpg'</span><span class="token punctuation">)</span>

</code></pre>
<p>运行程序后，将得到20次迭代后的图像，如下图<br /> <a href="https://imgchr.com/i/id2L4g" rel="nofollow" data-token="4a367ce6fb687af0e162fa7a8cd15fd0"><img src="https://s1.ax1x.com/2018/10/17/id2L4g.jpg" alt="id2L4g.jpg"></a></p>
<ol start="3">
<li>生成大尺寸图片<br /> 上节生成的图片尺寸太小，这节通过代码，将生成的大尺寸的图片。上节中传递图片尺寸的参数是 <strong>img_noise</strong> ，如果 <strong>img_noise</strong> 传递更大的值，那么生成的图片尺寸就会更大。但是这样就出现一个问题，生成图片的过程是需要消耗内存/显存的，<strong>img_noise</strong> 传递的尺寸越大，消耗的内存/显存就越多，最终会因为内存/显存不足，导致渲染失败。如何解决这个问题呢，其实很简单，每次不对整张图片做优化，而是把图片分为几个部分，每次只对一部分做优化，这样消耗的内存/显存就是固定大小的。<br /> 新建 <strong>gen_multiscale.py</strong> 文件，写入如下代码，这个函数可以对任意大小的图像进行提督计算：</li>
</ol>
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">calc_grad_tiled</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> t_grad<span class="token punctuation">,</span> title_size<span class="token operator">=</span><span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">''' 对任意大小的图像计算梯度 :param img: :param t_grad: :param title_size:每次优化的大小 :return: '''</span>
    <span class="token comment"># 每次只对title_size*title_size大小的图像计算梯度</span>
    sz <span class="token operator">=</span> title_size
    h<span class="token punctuation">,</span> w <span class="token operator">=</span> img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>

    <span class="token comment"># 如果直接计算梯度，在每个 title_size * title_size 的边缘会出现比较明显的边缘效应，影响美观</span>
    <span class="token comment"># 解决的办法是：生成两个随机数 sx、sy，对图片进行整体移动</span>
    <span class="token comment"># img_shift 先在行上做整体移动，再在列上做整体移动</span>
    <span class="token comment"># 防止出现边缘效应</span>
    sx<span class="token punctuation">,</span> sy <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span>sz<span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
    img_shift <span class="token operator">=</span> np<span class="token punctuation">.</span>roll<span class="token punctuation">(</span>np<span class="token punctuation">.</span>roll<span class="token punctuation">(</span>img<span class="token punctuation">,</span> sx<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sy<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    grad <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>img<span class="token punctuation">)</span>
    <span class="token comment"># y,x是开始及位置的像素</span>
    <span class="token keyword">for</span> y <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">(</span>h <span class="token operator">-</span> sz <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">(</span>w <span class="token operator">-</span> sz <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 每次对sub计算梯度。sub的大小是title_size*title_size</span>
            sub <span class="token operator">=</span> img_shift<span class="token punctuation">[</span>y<span class="token punctuation">:</span>y <span class="token operator">+</span> sz<span class="token punctuation">,</span> x<span class="token punctuation">:</span>x <span class="token operator">+</span> sz<span class="token punctuation">]</span>
            g <span class="token operator">=</span> sess<span class="token punctuation">.</span>run<span class="token punctuation">(</span>t_grad<span class="token punctuation">,</span> <span class="token punctuation">{</span>t_input<span class="token punctuation">:</span> sub<span class="token punctuation">}</span><span class="token punctuation">)</span>
            grad<span class="token punctuation">[</span>y<span class="token punctuation">:</span>y <span class="token operator">+</span> sz<span class="token punctuation">,</span> x<span class="token punctuation">:</span>x <span class="token operator">+</span> sz<span class="token punctuation">]</span> <span class="token operator">=</span> g

        <span class="token comment"># 使用np.roll移回去</span>
        <span class="token keyword">return</span> np<span class="token punctuation">.</span>roll<span class="token punctuation">(</span>np<span class="token punctuation">.</span>roll<span class="token punctuation">(</span>grad<span class="token punctuation">,</span> <span class="token operator">-</span>sx<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span>sy<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

</code></pre>
<p>为了加快图像的收敛速度，可以采用先生成小尺寸，再将图片放大：</p>
<pre><code class="prism language-python"><span class="token comment"># 将图片放大ratio倍</span>
<span class="token keyword">def</span> <span class="token function">resize_ratio</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> ratio<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 首先确定源像素的范围</span>
    <span class="token builtin">min</span> <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token builtin">max</span> <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    img <span class="token operator">=</span> <span class="token punctuation">(</span>img <span class="token operator">-</span> <span class="token builtin">min</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token builtin">max</span> <span class="token operator">-</span> <span class="token builtin">min</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">255</span>
    img <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span>scipy<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>imresize<span class="token punctuation">(</span>img<span class="token punctuation">,</span> ratio<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 使用完 scipy.misc.imresize 函数后，将像素缩放回去</span>
    img <span class="token operator">=</span> img <span class="token operator">/</span> <span class="token number">255</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">max</span> <span class="token operator">-</span> <span class="token builtin">min</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">min</span>
    <span class="token keyword">return</span> img

<span class="token comment"># 生成大尺寸图片</span>
<span class="token keyword">def</span> <span class="token function">render_multiscale</span><span class="token punctuation">(</span>t_obj<span class="token punctuation">,</span> img0<span class="token punctuation">,</span> iter_n<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> step<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">,</span> octave_n<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> octave_scale<span class="token operator">=</span><span class="token number">1.4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">''' 生成大尺寸图片 :param t_obj: :param img0: :param iter_n: :param step: :param octave_n:放大次数 :param octave_scale:放大倍数 :return: '''</span>
    <span class="token comment"># 同样定义目标梯度</span>
    t_score <span class="token operator">=</span> tf<span class="token punctuation">.</span>reduce_mean<span class="token punctuation">(</span>t_obj<span class="token punctuation">)</span>
    t_grad <span class="token operator">=</span> tf<span class="token punctuation">.</span>gradients<span class="token punctuation">(</span>t_score<span class="token punctuation">,</span> t_input<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

    img <span class="token operator">=</span> img0<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 先生成小尺寸图像</span>
    <span class="token comment"># 然后调用 resize_ratio 将小尺寸图像放大 octave_scale 倍</span>
    <span class="token comment"># 再使用放大后的图像作为初始值进行计算</span>
    <span class="token keyword">for</span> octave <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>octave_n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> octave <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token comment"># 每次将图片放大octave_scale倍</span>
            <span class="token comment"># 共放大octave_n-1次</span>
            img <span class="token operator">=</span> resize_ratio<span class="token punctuation">(</span>img<span class="token punctuation">,</span> octave_scale<span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>iter_n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 计算任意大小图像的梯度</span>
            g <span class="token operator">=</span> calc_grad_tiled<span class="token punctuation">(</span>img<span class="token punctuation">,</span> t_grad<span class="token punctuation">)</span>
            g <span class="token operator">/=</span> g<span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">8</span>
            img <span class="token operator">+=</span> g <span class="token operator">*</span> step
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>
    savearray<span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token string">'multiscale.jpg'</span><span class="token punctuation">)</span>

</code></pre>
<p>下面编写主内容</p>
<pre><code class="prism language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    name <span class="token operator">=</span> <span class="token string">'mixed4d_3x3_bottleneck_pre_relu'</span>
    channel <span class="token operator">=</span> <span class="token number">139</span>
    img_noise <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">100.0</span>
    layer_output <span class="token operator">=</span> graph<span class="token punctuation">.</span>get_tensor_by_name<span class="token punctuation">(</span><span class="token string">"import/%s:0"</span> <span class="token operator">%</span> name<span class="token punctuation">)</span>
    render_multiscale<span class="token punctuation">(</span>layer_output<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> channel<span class="token punctuation">]</span><span class="token punctuation">,</span> img_noise<span class="token punctuation">,</span> iter_n<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>

</code></pre>
<p>运行代码后，将生成一张大尺寸的图片，如下图：<br /> <img src="https://s1.ax1x.com/2018/10/17/idfgEV.jpg" alt="idfgEV.jpg"><br /> 从图中可以看出，mixed4d_3x3_bottleneck_pre_relu 卷积层的第139个通道实际上就是学到了某种花朵的特征。</p>
<ol start="4">
<li>生成高质量图片<br /> 前面两节生成的图片都是分辨率不高的图片，这节将生成高质量的图片。在图像处理算法中，有 <strong>高频成分</strong> 和 <strong>低频成分</strong> 之分。所谓高频成分，是指图像中灰度、颜色、明度变化比较剧烈的地方，比如边缘、细节部分。低频成分是指图像变化不大的地方，比如大块色块、整体风格。<br /> 上节生成的图片高频成分太多，图片不够柔和。如何解决这个问题呢？一种方法是针对高频成分加入损失，这样图像在生成的时候就会因为新加入损失的作用二发生变化，但是加入损失会导致计算量和收敛步数增大。另一种方法是 <strong>放大低频梯度</strong> ，对梯度进行分解，降至分为 <strong>高频梯度</strong> 和 <strong>低频梯度</strong> ，在人为的去放大低频梯度，就可以得到较为柔和的图像。<br /> 一般情况下，要使用 <strong>拉普拉斯金字塔</strong> 对图像进行分解，这种算法可以把图片分解为多层。同时，也可以对梯队进行分解，分解之后，对高频的梯度和低频的梯度都做标准化，可以让梯度的低频成分和高频成分差不多，表现在图像上就会增加图像的低频成分，从而提高生成图像的质量。这种方法称为 <strong>拉普拉斯金字塔标准化</strong>，具体实现代码如下：</li>
</ol>
<pre><code class="prism language-python">k <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
k <span class="token operator">=</span> np<span class="token punctuation">.</span>outer<span class="token punctuation">(</span>k<span class="token punctuation">,</span> k<span class="token punctuation">)</span>
k5x5 <span class="token operator">=</span> k<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">/</span> k<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>eye<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>

<span class="token comment"># 这个函数将图像分为低频和高频成分</span>
<span class="token keyword">def</span> <span class="token function">lap_split</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> tf<span class="token punctuation">.</span>name_scope<span class="token punctuation">(</span><span class="token string">'split'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 做一次卷积相当于一次平滑，因此lo为低频成分</span>
        lo <span class="token operator">=</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img<span class="token punctuation">,</span> k5x5<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'SAME'</span><span class="token punctuation">)</span>
        <span class="token comment"># 低频成分缩放到原始图像大叫就得到lo2，再用原始图像img减去lo2，就得到高频成分hi</span>
        lo2 <span class="token operator">=</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>conv2d_transpose<span class="token punctuation">(</span>lo<span class="token punctuation">,</span> k5x5 <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">,</span> tf<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        hi <span class="token operator">=</span> img <span class="token operator">-</span> lo2
    <span class="token keyword">return</span> lo<span class="token punctuation">,</span> hi


<span class="token comment"># 这个函数将图像img分成n层拉普拉斯金字塔</span>
<span class="token keyword">def</span> <span class="token function">lap_split_n</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    levels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 调用lap_split将图像分为低频和高频部分</span>
        <span class="token comment"># 高频部分保存到levels中</span>
        <span class="token comment"># 低频部分再继续分解</span>
        img<span class="token punctuation">,</span> hi <span class="token operator">=</span> lap_split<span class="token punctuation">(</span>img<span class="token punctuation">)</span>
        levels<span class="token punctuation">.</span>append<span class="token punctuation">(</span>hi<span class="token punctuation">)</span>
    levels<span class="token punctuation">.</span>append<span class="token punctuation">(</span>img<span class="token punctuation">)</span>
    <span class="token keyword">return</span> levels<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>


<span class="token comment"># 将拉普拉斯金字塔还原到原始图像</span>
<span class="token keyword">def</span> <span class="token function">lap_merge</span><span class="token punctuation">(</span>levels<span class="token punctuation">)</span><span class="token punctuation">:</span>
    img <span class="token operator">=</span> levels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> hi <span class="token keyword">in</span> levels<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">with</span> tf<span class="token punctuation">.</span>name_scope<span class="token punctuation">(</span><span class="token string">'merge'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            img <span class="token operator">=</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>conv2d_transpose<span class="token punctuation">(</span>img<span class="token punctuation">,</span> k5x5 <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">,</span> tf<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>hi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> hi
    <span class="token keyword">return</span> img


<span class="token comment"># 对img做标准化</span>
<span class="token keyword">def</span> <span class="token function">normalize_std</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> eps<span class="token operator">=</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> tf<span class="token punctuation">.</span>name_scope<span class="token punctuation">(</span><span class="token string">'normalize'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        std <span class="token operator">=</span> tf<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>reduce_mean<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>square<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> img <span class="token operator">/</span> tf<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span>std<span class="token punctuation">,</span> eps<span class="token punctuation">)</span>


<span class="token comment"># 拉普拉斯金字塔标准化</span>
<span class="token keyword">def</span> <span class="token function">lap_normalize</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> scale_n<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    img <span class="token operator">=</span> tf<span class="token punctuation">.</span>expand_dims<span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    tlevels <span class="token operator">=</span> lap_split_n<span class="token punctuation">(</span>img<span class="token punctuation">,</span> scale_n<span class="token punctuation">)</span>
    <span class="token comment"># 每一层都做一个normalize_std</span>
    tlevels <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span>normalize_std<span class="token punctuation">,</span> tlevels<span class="token punctuation">)</span><span class="token punctuation">)</span>
    out <span class="token operator">=</span> lap_merge<span class="token punctuation">(</span>tlevels<span class="token punctuation">)</span>
    <span class="token keyword">return</span> out<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>
</code></pre>
<p>编写完拉普拉斯标准化函数后，现在编写生成图像的代码：</p>
<pre><code class="prism language-python"><span class="token comment"># 将一个Tensor函数转换成numpy.ndarray 函数</span>
<span class="token keyword">def</span> <span class="token function">tffunc</span><span class="token punctuation">(</span><span class="token operator">*</span>argtypes<span class="token punctuation">)</span><span class="token punctuation">:</span>
    placeholders <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>placeholder<span class="token punctuation">,</span> argtypes<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">wrap</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">:</span>
        out <span class="token operator">=</span> f<span class="token punctuation">(</span><span class="token operator">*</span>placeholders<span class="token punctuation">)</span>

        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> out<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token builtin">zip</span><span class="token punctuation">(</span>placeholders<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> session<span class="token operator">=</span>kw<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'session'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span> wrapper

    <span class="token keyword">return</span> wrap


<span class="token keyword">def</span> <span class="token function">render_lapnorm</span><span class="token punctuation">(</span>t_obj<span class="token punctuation">,</span> img0<span class="token punctuation">,</span>
                   iter_n<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> step<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">,</span> octave_n<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> octave_scale<span class="token operator">=</span><span class="token number">1.4</span><span class="token punctuation">,</span> lap_n<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 同样定义目标和梯度</span>
    t_score <span class="token operator">=</span> tf<span class="token punctuation">.</span>reduce_mean<span class="token punctuation">(</span>t_obj<span class="token punctuation">)</span>
    t_grad <span class="token operator">=</span> tf<span class="token punctuation">.</span>gradients<span class="token punctuation">(</span>t_score<span class="token punctuation">,</span> t_input<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token comment"># 将lap_normalize转换为正常函数</span>
    lap_norm_func <span class="token operator">=</span> tffunc<span class="token punctuation">(</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span><span class="token punctuation">(</span>partial<span class="token punctuation">(</span>lap_normalize<span class="token punctuation">,</span> scale_n<span class="token operator">=</span>lap_n<span class="token punctuation">)</span><span class="token punctuation">)</span>

    img <span class="token operator">=</span> img0<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> octave <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>octave_n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> octave <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
            img <span class="token operator">=</span> resize_ratio<span class="token punctuation">(</span>img<span class="token punctuation">,</span> octave_scale<span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>iter_n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            g <span class="token operator">=</span> calc_grad_tiled<span class="token punctuation">(</span>img<span class="token punctuation">,</span> t_grad<span class="token punctuation">)</span>
            <span class="token comment"># 唯一的区别在于我们使用lap_norm_func来标准化g！</span>
            g <span class="token operator">=</span> lap_norm_func<span class="token punctuation">(</span>g<span class="token punctuation">)</span>
            img <span class="token operator">+=</span> g <span class="token operator">*</span> step
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>
    savearray<span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token string">'lapnorm.jpg'</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    name <span class="token operator">=</span> <span class="token string">'mixed4d_3x3_bottleneck_pre_relu'</span>
    channel <span class="token operator">=</span> <span class="token number">139</span>
    img_noise <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">100.0</span>
    layer_output <span class="token operator">=</span> graph<span class="token punctuation">.</span>get_tensor_by_name<span class="token punctuation">(</span><span class="token string">'import/%s:0'</span> <span class="token operator">%</span> name<span class="token punctuation">)</span>
    render_lapnorm<span class="token punctuation">(</span>layer_output<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> channel<span class="token punctuation">]</span><span class="token punctuation">,</span> img_noise<span class="token punctuation">,</span> iter_n<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>

</code></pre>
<p>运行上面代码后，将生成高质量的图片：<br /> <img src="https://s1.ax1x.com/2018/10/18/iwAYNt.jpg" alt="iwAYNt.jpg"></p>
<ol start="5">
<li>生成最终的图片<br /> 前面已经讲解了如何通过极大化卷积层摸个通道的平均值生成图片，并学习了如何生成更大和质量更高的图像。但是最终的Deep Dream 模型还需要对图片添加一个背景。具体代码如下：</li>
</ol>
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">resize</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> hw<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token builtin">min</span> <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token builtin">max</span> <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    img <span class="token operator">=</span> <span class="token punctuation">(</span>img <span class="token operator">-</span> <span class="token builtin">min</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token builtin">max</span> <span class="token operator">-</span> <span class="token builtin">min</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">255</span>
    img <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span>scipy<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>imresize<span class="token punctuation">(</span>img<span class="token punctuation">,</span> hw<span class="token punctuation">)</span><span class="token punctuation">)</span>
    img <span class="token operator">=</span> img <span class="token operator">/</span> <span class="token number">255</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">max</span> <span class="token operator">-</span> <span class="token builtin">min</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">min</span>
    <span class="token keyword">return</span> img


<span class="token keyword">def</span> <span class="token function">render_deepdream</span><span class="token punctuation">(</span>t_obj<span class="token punctuation">,</span> img0<span class="token punctuation">,</span> iter_n<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> step<span class="token operator">=</span><span class="token number">1.5</span><span class="token punctuation">,</span> octave_n<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> octave_scale<span class="token operator">=</span><span class="token number">1.4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    t_score <span class="token operator">=</span> tf<span class="token punctuation">.</span>reduce_mean<span class="token punctuation">(</span>t_obj<span class="token punctuation">)</span>
    t_grad <span class="token operator">=</span> tf<span class="token punctuation">.</span>gradients<span class="token punctuation">(</span>t_score<span class="token punctuation">,</span> t_input<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

    img <span class="token operator">=</span> img0
    <span class="token comment"># 同样将图像进行金字塔分解</span>
    <span class="token comment"># 提取高频和低频的方法比较简单，直接缩放</span>
    octaves <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>octave_n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        hw <span class="token operator">=</span> img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>
        lo <span class="token operator">=</span> resize<span class="token punctuation">(</span>img<span class="token punctuation">,</span> np<span class="token punctuation">.</span>int32<span class="token punctuation">(</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span>hw<span class="token punctuation">)</span> <span class="token operator">/</span> octave_scale<span class="token punctuation">)</span><span class="token punctuation">)</span>
        hi <span class="token operator">=</span> img <span class="token operator">-</span> resize<span class="token punctuation">(</span>lo<span class="token punctuation">,</span> hw<span class="token punctuation">)</span>
        img <span class="token operator">=</span> lo
        octaves<span class="token punctuation">.</span>append<span class="token punctuation">(</span>hi<span class="token punctuation">)</span>

    <span class="token comment"># 先生成低频的图像，再依次放大并加上高频</span>
    <span class="token keyword">for</span> octave <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>octave_n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> octave <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
            hi <span class="token operator">=</span> octaves<span class="token punctuation">[</span><span class="token operator">-</span>octave<span class="token punctuation">]</span>
            img <span class="token operator">=</span> resize<span class="token punctuation">(</span>img<span class="token punctuation">,</span> hi<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> hi
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>iter_n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            g <span class="token operator">=</span> calc_grad_tiled<span class="token punctuation">(</span>img<span class="token punctuation">,</span> t_grad<span class="token punctuation">)</span>
            img <span class="token operator">+=</span> g <span class="token operator">*</span> <span class="token punctuation">(</span>step <span class="token operator">/</span> <span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>

    img <span class="token operator">=</span> img<span class="token punctuation">.</span>clip<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span>
    savearray<span class="token punctuation">(</span>img<span class="token punctuation">,</span> <span class="token string">'deepdream.jpg'</span><span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    img0 <span class="token operator">=</span> PIL<span class="token punctuation">.</span>Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'test.jpg'</span><span class="token punctuation">)</span>
    img0 <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span>img0<span class="token punctuation">)</span>

    <span class="token comment"># name = 'mixed4d_3x3_bottleneck_pre_relu'</span>
    name <span class="token operator">=</span> <span class="token string">'mixed4c'</span>
    <span class="token comment"># channel = 139</span>
    layer_output <span class="token operator">=</span> graph<span class="token punctuation">.</span>get_tensor_by_name<span class="token punctuation">(</span><span class="token string">'import/%s:0'</span> <span class="token operator">%</span> name<span class="token punctuation">)</span>
    <span class="token comment"># render_deepdream(layer_output[:, :, :, channel], img0, iter_n=150)</span>
    render_deepdream<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>square<span class="token punctuation">(</span>layer_output<span class="token punctuation">)</span><span class="token punctuation">,</span> img0<span class="token punctuation">)</span>

</code></pre>
<h4><a id="_396"></a>三、代码下载地址</h4>
<p><a href="https://pan.baidu.com/s/1U3_4Eq31_Cv4tKzDTp8Ulg" rel="nofollow" data-token="080c793f943ecd1be6b867468e08f33c">下载地址</a></p>
</p></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e9f16cbbc2.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
		<item>
		<title>八个最佳Python IDE</title>
		<link>https://uzzz.org/article/1513.html</link>
				<pubDate>Sat, 01 Oct 2016 23:34:34 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[pythonide]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/1513.html</guid>
				<description><![CDATA[转载至 &#160;&#160;http://blog.csdn.net/chszs Python是一种功能强大、语言简洁的编程语言。本文向大家推荐8个适合Python开发的IDE。 1. Eclipse with PyDev http://pydev.org/ Eclipse+PyDev插件，很适合开发Python Web应用，其特征包括自动代码完成、语法高亮、代码分析、调试器、以及内置的交互浏览器。 2. Komodo Edit http://komodoide.com/komodo-edit/ Komodo Edit是一个免费的、开源的、专业的Python IDE，其特征是非菜单的操作方式，开发高效。 3. Vim http://www.vim.org/download.php Vim是一个简洁、高效的工具，也适合做Python开发。 4. Sublime Text http://www.sublimetext.com/ SublimeText也是适合Python开发的IDE工具，SublimeText虽然仅仅是一个编辑器，但是它有丰富的插件，使得对Python开发的支持非常到位。 5. Pycharm http://www.jetbrains.com/pycharm/ Pycharm是一个跨平台的Python开发工具，是JetBrains公司的产品。其特征包括：自动代码完成、集成的Python调试器、括号自动匹配、代码折叠。Pycharm支持Windows、MacOS以及Linux等系统，而且可以远程开发、调试、运行程序。 6. Emacs http://www.gnu.org/software/emacs/ Emacs是一个可扩展的文本编辑器，同样支持Python开发。Emacs本身以Lisp解释器作为其核心，而且包含了大量的扩展。 7. Wing https://wingware.com/ Wing是一个Python语言的超强IDE，适合做交互式的Python开发。Wing IDE同样支持自动代码完成、代码错误检查、开发技巧提示等，而且Wing IDE也支持多种操作系统，包括Windows、Linux和Mac OS X。 8. Pyscripter https://code.google.com/p/pyscripter/ Pyscriptor是一个开源的Python集成开发环境，很富有竞争力，同样有诸如代码自动完成、语法检查、视图分割文件编辑等功能。]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;">
<h5 id="作者chszs转载需注明博客主页httpblogcsdnnetchszs" style="font-weight:100;font-family:'microsoft yahei';line-height:26px;"> 转载至 &nbsp;&nbsp;<a href="http://blog.csdn.net/chszs" rel="nofollow" style="color:rgb(255,153,0);text-decoration:none;" data-token="c3c2c79e36d76c8cd39f21ff71598879">http://blog.csdn.net/chszs</a></h5>
</p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <a href="http://lib.csdn.net/base/11" rel="nofollow" class="replace_word" title="undefined" style="color:rgb(223,52,52);text-decoration:none;font-weight:bold;" data-token="f226c60a05b62f5ed4b25bdb98668d63">Python</a>是一种功能强大、语言简洁的编程语言。本文向大家推荐8个适合Python开发的IDE。</p>
<h3 id="1-eclipse-with-pydev" style="font-weight:100;font-family:'microsoft yahei';line-height:26px;"> <a name="t2" style="color:rgb(255,153,0);"></a>1. Eclipse with PyDev</h3>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <a href="http://pydev.org/" rel="nofollow" style="color:rgb(255,153,0);text-decoration:none;" data-token="fc485b2d0322db9979d350a510b87a28">http://pydev.org/</a></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150522224834814" alt="这里写图片描述" title="" style="border:none;"></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> Eclipse+PyDev插件，很适合开发Python Web应用，其特征包括自动代码完成、语法高亮、代码分析、调试器、以及内置的交互浏览器。</p>
<h3 id="2-komodo-edit" style="font-weight:100;font-family:'microsoft yahei';line-height:26px;"> <a name="t3" style="color:rgb(255,153,0);"></a>2. Komodo Edit</h3>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <a href="http://komodoide.com/komodo-edit/" rel="nofollow" style="color:rgb(255,153,0);text-decoration:none;" data-token="27f260f38b426d43bd40aefae1530684">http://komodoide.com/komodo-edit/</a></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150522224942007" alt="这里写图片描述" title="" style="border:none;"></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> Komodo Edit是一个免费的、开源的、专业的Python IDE，其特征是非菜单的操作方式，开发高效。</p>
<h3 id="3-vim" style="font-weight:100;font-family:'microsoft yahei';line-height:26px;"> <a name="t4" style="color:rgb(255,153,0);"></a>3. Vim</h3>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <a href="http://www.vim.org/download.php" rel="nofollow" style="color:rgb(255,153,0);text-decoration:none;" data-token="c90d3bc64803be7a15f56ba211f34c57">http://www.vim.org/download.php</a></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150522225002146" alt="这里写图片描述" title="" style="border:none;"></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> Vim是一个简洁、高效的工具，也适合做Python开发。</p>
<h3 id="4-sublime-text" style="font-weight:100;font-family:'microsoft yahei';line-height:26px;"> <a name="t5" style="color:rgb(255,153,0);"></a>4. Sublime Text</h3>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <a href="http://www.sublimetext.com/" rel="nofollow" style="color:rgb(255,153,0);text-decoration:none;" data-token="fbbb4d17f79eb63451fcd50ab96c69b8">http://www.sublimetext.com/</a></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150522224952049" alt="这里写图片描述" title="" style="border:none;"></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> SublimeText也是适合Python开发的IDE工具，SublimeText虽然仅仅是一个编辑器，但是它有丰富的插件，使得对Python开发的支持非常到位。</p>
<h3 id="5-pycharm" style="font-weight:100;font-family:'microsoft yahei';line-height:26px;"> <a name="t6" style="color:rgb(255,153,0);"></a>5. Pycharm</h3>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <a href="http://www.jetbrains.com/pycharm/" rel="nofollow" style="color:rgb(255,153,0);text-decoration:none;" data-token="7a65e64bf8bca1d812d9a0aad5675ad1">http://www.jetbrains.com/pycharm/</a></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150522225052768" alt="这里写图片描述" title="" style="border:none;"></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> Pycharm是一个跨平台的Python开发工具，是JetBrains公司的产品。其特征包括：自动代码完成、集成的Python调试器、括号自动匹配、代码折叠。Pycharm支持Windows、MacOS以及Linux等系统，而且可以远程开发、调试、运行程序。</p>
<h3 id="6-emacs" style="font-weight:100;font-family:'microsoft yahei';line-height:26px;"> <a name="t7" style="color:rgb(255,153,0);"></a>6. Emacs</h3>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <a href="http://www.gnu.org/software/emacs/" rel="nofollow" style="color:rgb(255,153,0);text-decoration:none;" data-token="6a7cb51c578b6c20fc76bed708319f7a">http://www.gnu.org/software/emacs/</a></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150522225035636" alt="这里写图片描述" title="" style="border:none;"></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> Emacs是一个可扩展的文本编辑器，同样支持Python开发。Emacs本身以Lisp解释器作为其核心，而且包含了大量的扩展。</p>
<h3 id="7-wing" style="font-weight:100;font-family:'microsoft yahei';line-height:26px;"> <a name="t8" style="color:rgb(255,153,0);"></a>7. Wing</h3>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <a href="https://wingware.com/" rel="nofollow" style="color:rgb(255,153,0);text-decoration:none;" data-token="7a052725d00830b9b4a83410dda2d7de">https://wingware.com/</a></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150522225055151" alt="这里写图片描述" title="" style="border:none;"></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> Wing是一个Python语言的超强IDE，适合做交互式的Python开发。Wing IDE同样支持自动代码完成、代码错误检查、开发技巧提示等，而且Wing IDE也支持多种操作系统，包括Windows、Linux和Mac OS X。</p>
<h3 id="8-pyscripter" style="font-weight:100;font-family:'microsoft yahei';line-height:26px;"> <a name="t9" style="color:rgb(255,153,0);"></a>8. Pyscripter</h3>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <a href="https://code.google.com/p/pyscripter/" rel="nofollow" style="color:rgb(255,153,0);text-decoration:none;" data-token="cd354f7412baabacb5e53b001446660d">https://code.google.com/p/pyscripter/</a></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150522225151596" alt="这里写图片描述" title="" style="border:none;"></p>
<p style="font-family:'microsoft yahei';font-size:14px;line-height:26px;"> Pyscriptor是一个开源的Python集成开发环境，很富有竞争力，同样有诸如代码自动完成、语法检查、视图分割文件编辑等功能。</p>
</p></div>
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
